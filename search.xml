<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>python笔记--环境搭建之Anaconda</title>
      <link href="/2019/08/24/python%E7%AC%94%E8%AE%B0-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B9%8BAnaconda/"/>
      <url>/2019/08/24/python%E7%AC%94%E8%AE%B0-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B9%8BAnaconda/</url>
      
        <content type="html"><![CDATA[<p>原本一开始的时候不想记录这篇文章，可是从自己初步接触python到目前为止，遇到的包混乱和python版本切换的问题层出不穷，也曾多次翻看其他人的博客和帖子寻求答案，耗时耗力不说，最终自己本地的开发环境也被污染了，作为一个有代码洁癖的人来说，很难忍受这这些，然后就一次又一次的重装系统…<br>写这篇文章记录的时候，我是刚刚把系统重装结束，苦于教训，最终记录一下过程和这个工具的使用。  </p><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p>Anaconda主要是用来做python的环境管理和包管理  </p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>安装过于简单，这里不详细介绍，主要是下载。大多数人一开始都是习惯去官网下载，这里我也放出官网的下载地址<a href="https://www.anaconda.com/" target="_blank" rel="noopener">Anaconda下载</a>。在下载的过程中，你可能会过于痛苦，我第一次的时候是下载了半个小时，后来我找到一个东西，叫做<a href="https://mirror.tuna.tsinghua.edu.cn/help/anaconda/" target="_blank" rel="noopener">清华大学开源软件镜像站</a> ，当你打开这个下载的时候，你会发现，下载是如此的丝滑。  </p><h3 id="操作教程"><a href="#操作教程" class="headerlink" title="操作教程"></a>操作教程</h3><p>这里介绍两种，安装完成后，加入环境变量，就可以起飞了，最简单的操作就是打开软件，在可视化界面操作   </p><h4 id="可视化界面"><a href="#可视化界面" class="headerlink" title="可视化界面"></a>可视化界面</h4><p><img src="//wanmisy.github.io/2019/08/24/python笔记-环境搭建之Anaconda/Anaconda%E5%8F%AF%E8%A7%86%E5%8C%96%E7%95%8C%E9%9D%A2.png" alt>  </p><ul><li>点击Environment，则可以显示目前安装的所有环境</li><li>create新建环境</li><li>clone克隆环境</li><li>remove删除环境   </li></ul><h4 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h4><p>作为一个逼格满满的程序员怎么可以用可视化的界面呢？下面主要记录一下基本的命令使用</p><ul><li>首选可定是我们的帮助命令，当你忘记怎么使用时，立刻在你的命令行，输<code>conda --help</code>  </li><li><code>conda --version</code> ： 显示Conda版本信息</li><li><code>conda update conda</code> ： 更新conda到最新版本</li><li><code>conda create --name env_name [package_name]</code> : 新创建一个名为env_name的环境，并在环境中安装名为package_name的包【可选操作】  </li><li><code>activate env_name</code> : ：将当前工作环境切换到名为env_name</li><li><code>conda create --name env_name python=3.6</code> ：新建一个环境并安装python3.6</li><li><code>conda search package_name</code> ：在Anaconda仓库中搜索名为package_name的包是否存在【需要联网】  </li><li><code>conda install package_name</code>：在当前环境下安装名为package_name的包</li><li><code>conda list</code> : 查看当前环境下安装的package信息</li><li><code>conda update --all</code> : 更新当前环境下安装的全部package到最新版本</li><li><code>conda update python</code> : 更新当前环境下python版本到当前python版本的最新版本</li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> Anaconda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDFS(hadoop分布式文件系统)</title>
      <link href="/2019/05/22/HDFS-hadoop%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
      <url>/2019/05/22/HDFS-hadoop%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="HDFS-hadoop分布式文件系统"><a href="#HDFS-hadoop分布式文件系统" class="headerlink" title="HDFS(hadoop分布式文件系统)"></a>HDFS(hadoop分布式文件系统)</h2><p><img src="//wanmisy.github.io/2019/05/22/HDFS-hadoop分布式文件系统/5c87a10634075.jpg" alt="5c87a10634075"></p><h4 id="一、特点"><a href="#一、特点" class="headerlink" title="一、特点"></a>一、特点</h4><ul><li>可存储超大文件</li><li>一次写入，多次读取</li><li>运行在普通廉价的机器</li></ul><a id="more"></a><h4 id="二、不适用场景"><a href="#二、不适用场景" class="headerlink" title="二、不适用场景"></a>二、不适用场景</h4><ul><li>低延迟</li><li>大量小文件</li><li>多用户更新</li><li>结构化数据</li><li>数据量不大</li></ul><h4 id="三、基本命令"><a href="#三、基本命令" class="headerlink" title="三、基本命令"></a>三、基本命令</h4><ul><li><p>打印文件列表（ls） </p><pre><code class="vim">标准写法： hadoop fs -ls hdfs:/  #hdfs: 明确说明是HDFS系统路径 简写： hadoop fs -ls /   #默认是HDFS系统下的根目录 打印指定子目录： hadoop fs -ls /package/test/ #HDFS系统下某个目录 </code></pre></li><li><p>上传文件、目录（put、copyFromLocal）<br>put用法：</p><pre><code>上传新文件： hdfs fs -put file:/root/test.txt hdfs:/   #上传本地test.txt文件到HDFS根目录，HDFS 根目录须无同名文件，否则“File exists” hdfs fs -put test.txt /test2.txt   #上传并重命名文件。 hdfs fs -put test1.txt test2.txt hdfs:/   #一次上传多个文件到HDFS路径。 上传文件夹： hdfs fs -put mypkg /newpkg    #上传并重命名了文件夹。 覆盖上传： hdfs fs -put -f /root/test.txt /   #如果HDFS目录中有同名文件会被覆盖 </code></pre><p>copyFromLocal用法： </p><pre><code>上传文件并重命名： hadoop fs -copyFromLocal file:/test.txt hdfs:/test2.txt 覆盖上传： hadoop fs -copyFromLocal -f test.txt /test.txt </code></pre></li></ul><ul><li><p>下载文件、目录（get、copyToLocal） </p><pre><code>拷贝文件到本地目录： hadoop fs -get hdfs:/test.txt file:/root/ 拷贝文件并重命名，可以简写： hadoop fs -get /test.txt /root/test.txt </code></pre></li></ul><ul><li><p>拷贝文件、目录（cp） </p><pre><code>从本地到HDFS，同put hadoop fs -cp file:/test.txt hdfs:/test2.txt  从HDFS到HDFS hadoop fs -cp hdfs:/test.txt hdfs:/test2.txt  hadoop fs -cp /test.txt /test2.txt </code></pre></li></ul><ul><li><p>移动文件（mv） </p><pre><code>hadoop fs -mv hdfs:/test.txt hdfs:/dir/test.txt  hadoop fs -mv /test.txt /dir/test.txt</code></pre></li></ul><ul><li><p>删除文件、目录（rm） </p><pre><code>删除指定文件 hadoop fs -rm /a.txt  删除全部txt文件 hadoop fs -rm /*.txt  递归删除全部文件和目录 hadoop fs -rm -R /dir/ </code></pre></li></ul><ul><li><p>读取文件（cat、tail） </p><pre><code>hadoop fs -cat /test.txt  #以字节码的形式读取 hadoop fs -tail /test.txt </code></pre></li></ul><ul><li><p>创建空文件（touchz） </p><pre><code>hadoop fs - touchz /newfile.txt </code></pre></li></ul><ul><li><p>创建文件夹（mkdir） </p><pre><code>hadoop fs -mkdir /newdir /newdir2    #可以同时创建多个 hadoop fs -mkdir -p /newpkg/newpkg2/newpkg3  #同时创建父级目录 </code></pre></li></ul><ul><li><p>获取逻辑空间文件、目录大小（du） </p><pre><code>hadoop fs - du /   #显示HDFS根目录中各文件和文件夹大小 hadoop fs -du -h /   #以最大单位显示HDFS根目录中各文件和文件夹大小 hadoop fs -du -s /   #仅显示HDFS根目录大小。即各文件和文件夹大小之和  </code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据,hadoop,HDFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java8实战之Lambda表达式</title>
      <link href="/2019/04/20/java8%E5%AE%9E%E6%88%98%E4%B9%8BLambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2019/04/20/java8%E5%AE%9E%E6%88%98%E4%B9%8BLambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><h2 id="Ladmaba简介"><a href="#Ladmaba简介" class="headerlink" title="Ladmaba简介"></a>Ladmaba简介</h2><blockquote><p>Lambda表达式可以理解成可传递的匿名函数的一种方式，由参数、箭头和主体组成</p></blockquote><p>Lambada表达式只能配合函数式接口使用，那么什么是函数式接口呢？</p><ul><li>函数式接口：只有一个抽象方法的接口，可以用@FunctionalInterface标记</li></ul><h2 id="java8设计的几个常见的函数式接口"><a href="#java8设计的几个常见的函数式接口" class="headerlink" title="java8设计的几个常见的函数式接口"></a>java8设计的几个常见的函数式接口</h2><ol><li><p>Predicate</p><pre><code>@FunctionalInterfacepublic interface Predicate&lt;T&gt; {</code></pre></li></ol><p>   ​    /**</p><p>   ​     * Evaluates this predicate on the given argument.</p><p>   ​     *</p><p>   ​     * @param t the input argument</p><p>   ​     * @return {@code true} if the input argument matches the predicate,</p><p>   ​     * otherwise {@code false}</p><p>   ​     */</p><p>   ​    boolean test(T t);</p><p>   ​    …</p><p>   }</p><pre><code>2. Consumer </code></pre><p>   @FunctionalInterface</p><p>   public interface Consumer<t> {</t></p><p>   ​    /**</p><p>   ​     * Performs this operation on the given argument.</p><p>   ​     *</p><p>   ​     * @param t the input argument</p><p>   ​     */</p><p>   ​    void accept(T t);</p><p>   ​    …</p><p>   }</p><pre><code>3. Function  </code></pre><p>   @FunctionalInterface</p><p>   public interface Function&lt;T, R&gt; {</p><p>   ​    /**</p><p>   ​     * Applies this function to the given argument.</p><p>   ​     *</p><p>   ​     * @param t the function argument</p><p>   ​     * @return the function result</p><p>   ​     */</p><p>   ​    R apply(T t);</p><p>   ​    …</p><p>   }</p><pre><code>#### 注意任何函数式接口都不能抛出异常  那么如果我们需要Lambda表达式抛出异常，怎么办呢？这里提供两种解决方案  1. 定义及自己的函数接口</code></pre><p>   package io.github.jiangdequan;</p><p>   import java.io.BufferedReader;</p><p>   import java.io.File;</p><p>   import java.io.FileReader;</p><p>   import java.io.InputStreamReader;</p><p>   public class ReadProcessor {</p><p>   ​    public static void main(String[] args) throws Exception {</p><p>   ​        File file = new File(“D:\missj\java8_actual_combat\Lambda表达式\README.md”);</p><p>   ​        </p><p>   ​        BufferedReader bufferedReader = new BufferedReader(new FileReader(file));</p><p>   ​        FileProcessor processor = (arg) -&gt; arg.readLine();</p><p>   ​        String content = processor.process(bufferedReader);</p><p>   ​        System.out.println(content);</p><p>   ​    }</p><p>   ​    </p><p>   }</p><p>   @FunctionalInterface</p><p>   public interface FileProcessor{</p><p>   ​    String process(BufferedReader bufferedReader) throws Exception;</p><p>   }</p><pre><code>2. 使用java8的函数式接口显示的捕捉受检异常</code></pre><p>   package io.github.jiangdequan;</p><p>   import java.io.BufferedReader;</p><p>   import java.io.File;</p><p>   import java.io.FileReader;</p><p>   import java.io.InputStreamReader;</p><p>   import java.util.function.Function;</p><p>   public class ReadProcessor {</p><p>   ​    public static void main(String[] args) throws Exception {</p><p>   ​        File file = new File(“D:\missj\java8_actual_combat\Lambda表达式\README.md”);</p><p>   ​        </p><p>   ​        BufferedReader bufferedReader = new BufferedReader(new FileReader(file));</p><p>   ​        Function&lt;BufferedReader, String&gt; processor = (BufferedReader b) -&gt; {</p><p>   ​            b.readLine();</p><p>   ​        };</p><p>   ​        String content = processor.apply(bufferedReader);</p><p>   ​        System.out.println(content);</p><p>   ​    }</p><p>   ​    </p><p>   }</p><pre><code>#### 实战我们将苹果按照重量排序</code></pre><p>import java.util.ArrayList;</p><p>import java.util.List;</p><p>import static java.util.Comparator.comparing;</p><p>public class Filter {</p><p>​    public static void main(String[] args) {</p><p>​        Apple apple = new Apple(2.3, 5.0, “green”);</p><p>​        Apple apple1 = new Apple(1.0, 15.0, “red”);</p><p>​        Apple apple2 = new Apple(2.0, 10.0, “red”);</p><p>​        List<apple> list = new ArrayList&lt;&gt;();</apple></p><p>​        list.add(apple);</p><p>​        list.add(apple1);</p><p>​        list.add(apple2);</p><p>​        list.sort(comparing(Apple::getColor));</p><p>​        list.forEach(arg -&gt; System.out.println(arg.toString()));</p><p>​    }</p><p>​    </p><p>}</p><pre><code></code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java8实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java8之行为参数化传递</title>
      <link href="/2019/04/20/java8%E4%B9%8B%E8%A1%8C%E4%B8%BA%E5%8F%82%E6%95%B0%E5%8C%96%E4%BC%A0%E9%80%92/"/>
      <url>/2019/04/20/java8%E4%B9%8B%E8%A1%8C%E4%B8%BA%E5%8F%82%E6%95%B0%E5%8C%96%E4%BC%A0%E9%80%92/</url>
      
        <content type="html"><![CDATA[<h2 id="行为参数化传递代码"><a href="#行为参数化传递代码" class="headerlink" title="行为参数化传递代码"></a>行为参数化传递代码</h2><p>行为参数化是一种处理频繁变更需求的软件开发模式</p><p>例如现在有一个需求，我们需要筛选出所有的绿色的苹果，我们可以这么去操作<br><a href="https://gitee.com/missj/java8_actual_combat/tree/master/通过行为参数化传递代码/chapter2_1" target="_blank" rel="noopener">源码</a></p><pre><code>    public static List&lt;Apple&gt; filterGreenApple(List&lt;Apple&gt; inventory){        List&lt;Apple&gt; result = new ArrayList&lt;&gt;();        for (Apple var : inventory) {            if(&quot;green&quot;.equals(var.getColor())){                result.add(var);            }        }        return result;    }</code></pre><a id="more"></a><p>可是需求突然变更了，我们需要筛选出所有红色的苹果，当然，我们依然可以这么操作，将上述代码中的green改成red，这样也可以实现，但我们会发现存在大量重复代码，这时候我们发现先可以将颜色抽离出来作为一个参数<br><a href="https://gitee.com/missj/java8_actual_combat/tree/master/通过行为参数化传递代码/chapter2_2" target="_blank" rel="noopener">源码</a></p><pre><code>public static List&lt;Apple&gt; filterAppleByColor(List&lt;Apple&gt; inventory, String color){    List&lt;Apple&gt; result = new ArrayList&lt;&gt;();    for (Apple var : inventory) {        if(color.equals(var.getColor())){            result.add(var);        }    }    return result;}</code></pre><p>需求接着变更了，需要筛选重量，或者筛选颜色的时候需要筛选重量，你可能会想我们可以加一个判断变量<br><a href="https://gitee.com/missj/java8_actual_combat/tree/master/通过行为参数化传递代码/chapter2_3" target="_blank" rel="noopener">源码</a></p><pre><code>public static List&lt;Apple&gt; filter(List&lt;Apple&gt; invetory, double weight, String color, boolean flag){    List&lt;Apple&gt; result = new ArrayList&lt;&gt;();    if(flag){        for (Apple var : invetory) {            if(var.getWeight() &gt; weight){                result.add(var);            }        }    } else {        for (Apple var : invetory) {            if(color.equals(var.getColor())){                result.add(var);            }        }    }    return result;}</code></pre><p>上面的三种情况，我们都是通过添加更多参数来满足不断变化的需求，虽然也实现了功能，但是对于一个优秀的程序员来说，这种做法是非常差的，原因在于：1、代码冗余 2、扩展性差，不易维护 3、可读性差。<br>接下来我们来使用更高层次的抽象，行为参数化，我我们可以仿照策略设计模式编写一套标准，对不同的筛选情况定义算法<br><a href="https://gitee.com/missj/java8_actual_combat/tree/master/通过行为参数化传递代码/chapter2_4" target="_blank" rel="noopener">源码</a></p><pre><code>public interface ApplePredicate{    public boolean test(Apple apple);}public class AppleGreenColorPredicate implements ApplePredicate{    public boolean test(Apple apple){        if(&quot;green&quot;.equals(apple)){            return true;        }        return false;    }}public class AppleHeavyPredicate implements ApplePredicate{    public boolean test(Apple apple){        if(apple.getWeight() &gt; 2.0){            return true;        }        return false;    }}</code></pre><p>使用时调用对应的实现</p><pre><code>public static List&lt;Apple&gt; filter(List&lt;Apple&gt; invetory, ApplePredicate applePredicate){    List&lt;Apple&gt; result = new ArrayList&lt;&gt;();    ApplePredicate greenApplePre = new AppleGreenColorPredicate();    for (Apple var : invetory) {        if(greenApplePre.test(apple)){            result.add(var);        }    }}</code></pre><p>这个时候我们已将将行为参数化了，代码的可读性和可扩展性都得到了很大的提升，但是依然不够，当我们的需求不断变更的时候，就需要去写大量的实现类去扩展我们的算法，而这些算法很可能只使用一次，就不再使用了，接下来，我们考虑一下优化，使用匿名类<br><a href="https://gitee.com/missj/java8_actual_combat/tree/master/通过行为参数化传递代码/chapter2_5" target="_blank" rel="noopener">源码</a></p><pre><code>package io.github.jiangdequan;import java.util.ArrayList;import java.util.List;public class Filter  {    public static List&lt;Apple&gt; filter(List&lt;Apple&gt; invetory, ApplePredicate applePredicate){        List&lt;Apple&gt; result = new ArrayList&lt;&gt;();        for (Apple var : invetory) {            if(applePredicate.test(apple)){                result.add(var);            }        }    }    public static void main(String[] args) {        Apple apple = new Apple(2.3, 5.0, &quot;green&quot;);        Apple apple1 = new Apple(1.0, 15.0, &quot;red&quot;);        Apple apple2 = new Apple(2.0, 10.0, &quot;red&quot;);        List&lt;Apple&gt; list = new ArrayList&lt;&gt;();        list.add(apple);        list.add(apple1);        list.add(apple2);        // 筛选出所有绿色的苹果        List&lt;apple&gt; result = Filter.filter(list, new ApplePredicate(){            public boolean test(Apple apple){                if(&quot;red&quot;.equals(apple.getColor())){                    return true;                }                return false;            }        });        result.forEach(arg -&gt; System.out.println(apple.toString()));    }}public interface ApplePredicate{    public boolean test(Apple apple);}</code></pre><p>使用匿名类精简了很多，但依然显得笨重，接下来我们尝试使用Lambda表达式<br><a href="https://gitee.com/missj/java8_actual_combat/tree/master/通过行为参数化传递代码/chapter2_6" target="_blank" rel="noopener">源码</a></p><pre><code>package io.github.jiangdequan;import java.util.ArrayList;import java.util.List;public class Filter  {    public static List&lt;Apple&gt; filter(List&lt;Apple&gt; invetory, ApplePredicate applePredicate){        List&lt;Apple&gt; result = new ArrayList&lt;&gt;();        for (Apple var : invetory) {            if(applePredicate.test(apple)){                result.add(var);            }        }    }    public static void main(String[] args) {        Apple apple = new Apple(2.3, 5.0, &quot;green&quot;);        Apple apple1 = new Apple(1.0, 15.0, &quot;red&quot;);        Apple apple2 = new Apple(2.0, 10.0, &quot;red&quot;);        List&lt;Apple&gt; list = new ArrayList&lt;&gt;();        list.add(apple);        list.add(apple1);        list.add(apple2);        // 筛选出所有绿色的苹果        List&lt;apple&gt; result = Filter.filter(list, (Apple apple) -&gt; {            if(&quot;green&quot;.equals(apple.getColor())){                return true;            }            return false;        }        );        result.forEach(arg -&gt; System.out.println(apple.toString()));    }}public interface ApplePredicate{    public boolean test(Apple apple);}</code></pre><p>现在我们已经很好的完成了需求，可是突然要求变了，我们的产品不再是Apple，而是其他怎么办，我们可以用泛型对他再进行优化<br><a href="https://gitee.com/missj/java8_actual_combat/tree/master/通过行为参数化传递代码/chapter2_7" target="_blank" rel="noopener">源码</a></p><pre><code>package io.github.jiangdequan;import java.util.ArrayList;import java.util.List;public class Filter  {    public static T List&lt;T&gt; filter(List&lt;T&gt; invetory, Predicate&lt;T&gt; predicate){        List&lt;T&gt; result = new ArrayList&lt;&gt;();        for (T var : invetory) {            if(predicate.test(apple)){                result.add(var);            }        }    }    public static void main(String[] args) {        Apple apple = new Apple(2.3, 5.0, &quot;green&quot;);        Apple apple1 = new Apple(1.0, 15.0, &quot;red&quot;);        Apple apple2 = new Apple(2.0, 10.0, &quot;red&quot;);        List&lt;Apple&gt; list = new ArrayList&lt;&gt;();        list.add(apple);        list.add(apple1);        list.add(apple2);        // 筛选出所有绿色的苹果        List&lt;apple&gt; result = Filter.filter(list, (Apple apple) -&gt; {            if(&quot;green&quot;.equals(apple.getColor())){                return true;            }            return false;        }        );        result.forEach(arg -&gt; System.out.println(apple.toString()));    }}public interface Predicate&lt;T&gt;{    public boolean test(T t);}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java8实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot测试</title>
      <link href="/2018/12/25/springboot%E6%B5%8B%E8%AF%95/"/>
      <url>/2018/12/25/springboot%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="springboot测试"><a href="#springboot测试" class="headerlink" title="springboot测试"></a>springboot测试</h2><p>通常都是写 post测试，比较麻烦，这里我们介绍springboot test</p><a id="more"></a><pre><code class="(java)">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;    &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;</code></pre><pre><code class="(java)">@RunWith(SpringRunner.class)@SpringBootTestpublic class BootApplicationTests {    private MockMvc mockMvc;    @Before    public void setUp(){        mockMvc = MockMvcBuilders.standaloneSetup(new TestController()).build();    }    @Test    public void contextLoads() throws Exception {        mockMvc.perform(MockMvcRequestBuilders.post(&quot;/test?name=neo&quot;)        .accept(MediaType.APPLICATION_JSON_UTF8)).andDo(MockMvcResultHandlers.print());    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot,spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot热部署</title>
      <link href="/2018/12/25/springboot%E7%83%AD%E9%83%A8%E7%BD%B2/"/>
      <url>/2018/12/25/springboot%E7%83%AD%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="springboot热部署"><a href="#springboot热部署" class="headerlink" title="springboot热部署"></a>springboot热部署</h2><p>开发时，每次修改java代码，项目都需要重启，是不是很麻烦，这里提供一种热部署的方法，使用工具Devtools</p><pre><code class="(java)">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-Devtools&lt;/artifactId&gt;    &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;</code></pre><a id="more"></a><pre><code class="(java)">&lt;build&gt;    &lt;plugins&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;configuration&gt;                &lt;fork&gt;true&lt;/fork&gt;            &lt;/configuration&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/build&gt;</code></pre><p>如果是eclipse就已经可以了，如果是idea，还需要以下操作<br><img src="//wanmisy.github.io/2018/12/25/springboot热部署/WX20181225-143302@2x.png" alt><br>commond + shift + A，输入Registry<br><img src="//wanmisy.github.io/2018/12/25/springboot热部署/2C5204C3-8B24-4C69-BED1-9EE9B988CCC4.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot,spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot配置多数据源</title>
      <link href="/2018/12/25/springboot%E9%85%8D%E7%BD%AE%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90/"/>
      <url>/2018/12/25/springboot%E9%85%8D%E7%BD%AE%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<h2 id="springboot配置多数据源"><a href="#springboot配置多数据源" class="headerlink" title="springboot配置多数据源"></a>springboot配置多数据源</h2><pre><code class="(java)">/** * @ClassName TargetDataSource * @Description TODO * @Author missj * @Date 2018/12/6 11:54 * @Version 1.0 */@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface TargetDataSource {    String name() default &quot;&quot;;}</code></pre><a id="more"></a><pre><code>/** * @ClassName DataSourceNames * @Description TODO * @Author missj * @Date 2018/12/6 11:57 * @Version 1.0 */public interface DataSourceNames {    String FIRST = &quot;first&quot;;    String SECOND = &quot;second&quot;;}</code></pre><pre><code>public class DynamicDataSource extends AbstractRoutingDataSource {    private static final ThreadLocal&lt;String&gt; contextHolder = new ThreadLocal&lt;&gt;();    public DynamicDataSource(DataSource defaultDatasource, Map&lt;Object, Object&gt; targetDataSources) {        super.setDefaultTargetDataSource(defaultDatasource);        super.setTargetDataSources(targetDataSources);        super.afterPropertiesSet();    }    public static String getDatasource(){        return contextHolder.get();    }    @Override    protected Object determineCurrentLookupKey() {        return getDatasource();    }    public static void setDatasource(String datasource){        contextHolder.set(datasource);    }    public static void clearDatasource(){        contextHolder.remove();    }}</code></pre><pre><code>@Configurationpublic class MultiDataSourceConfig {    @Bean    @ConfigurationProperties(&quot;spring.datasource.druid.one&quot;)    public DataSource firstDataSource(){        return DruidDataSourceBuilder.create().build();    }    @Bean    @ConfigurationProperties(&quot;spring.datasource.druid.two&quot;)    public DataSource secondDataSource(){        return DruidDataSourceBuilder.create().build();    }    @Bean    @Primary    public DynamicDataSource dataSource(DataSource firstDataSource, DataSource secondDataSource){        Map&lt;Object, Object&gt; targetDataSources = new HashMap&lt;&gt;();        targetDataSources.put(DataSourceNames.FIRST, firstDataSource);        targetDataSources.put(DataSourceNames.SECOND, secondDataSource);        return new DynamicDataSource(firstDataSource, targetDataSources);    }}</code></pre><pre><code>@Aspect@Componentpublic class DatasourceAspect implements Ordered {    @Pointcut(&quot;@annotation(com.missj.config.datasource.annotation.TargetDataSource)&quot;)    public void dataSourcePointCut() {    }    @Around(&quot;dataSourcePointCut()&quot;)    public Object around(ProceedingJoinPoint point) throws Throwable{        MethodSignature signature = (MethodSignature)point.getSignature();        Method method = signature.getMethod();        TargetDataSource ds = method.getAnnotation(TargetDataSource.class);        if (ds == null){            DynamicDataSource.setDatasource(DataSourceNames.FIRST);        } else {            DynamicDataSource.setDatasource(ds.name());        }        try {            return point.proceed();        }finally {            DynamicDataSource.clearDatasource();        }    }    @Override    public int getOrder() {        return 1;    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot,spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker</title>
      <link href="/2018/12/24/docker/"/>
      <url>/2018/12/24/docker/</url>
      
        <content type="html"><![CDATA[<h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><h5 id="查看docker版本【docker-version】"><a href="#查看docker版本【docker-version】" class="headerlink" title="查看docker版本【docker version】"></a>查看docker版本【docker version】</h5><p><img src="//wanmisy.github.io/2018/12/24/docker/WX20181224-104417@2x.png" alt="docker version"></p><h3 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h3><p>命令行<code>docker [image] pull NAME[:TAG]</code>  </p><p>注：NAME是仓库名称、TAG是镜像的标签（通常用来表示版本信息），不制定TAG，则默认为latest，镜像的内容会跟踪最新版本的变更而变化，内容不稳定，因此建议加加上TAG  </p><p>例如下载ubuntu:18.04  </p><pre><code class="linux">docker image pull ubuntu:18.04</code></pre><h3 id="查看镜像信息"><a href="#查看镜像信息" class="headerlink" title="查看镜像信息"></a>查看镜像信息</h3><ul><li><p>列出镜像<code>docker images</code>或<code>docker image ls</code></p></li><li><p>使用tag添加镜像标签<code>docker tag ubuntu:18.04 myubuntu:18.04</code></p><p><em>以后就可以用myubuntu:18.04来代表ubuntu:18.04这个镜像了,此时这两个的image_id相同，所以实际上他们指向同一个镜像文件</em></p></li><li><p>使用inspest查看详细信息</p><p>查询ubuntu:18.04的详细信息<code>docker inspect ubuntu:18.04</code></p></li><li><p>使用history查看历史镜像<code>docker history ubuntu:18.04</code></p></li></ul><h3 id="搜寻镜像"><a href="#搜寻镜像" class="headerlink" title="搜寻镜像"></a>搜寻镜像</h3><pre><code class="linux">docker search [option] keyword</code></pre><h3 id="删除和清理镜像"><a href="#删除和清理镜像" class="headerlink" title="删除和清理镜像"></a>删除和清理镜像</h3><ul><li><p>使用标签删除镜像  </p><blockquote><p>删除命令为<code>docker rmi IMAGE[IMAGE...]</code>或<code>docker image rm IMG[IMG...]</code></p><p>支持选项：  </p><p>-f,–force 强制删除</p><p>-no-prune 不要清理未带镜像的父标签  </p><p>注：docker rmi后面可以是TAG，也可以是IMAGE_ID</p></blockquote></li><li><p>清理镜像</p><blockquote><p>docker image prune</p><p>支持选项</p><p>-a,-all 删除所有无用镜像</p><p>-filter filter 只删除符合给定过滤器的的镜像</p><p>-f,force 强制删除镜像  </p></blockquote></li></ul><h3 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h3><ul><li><p>基于已有容器的创建</p><blockquote><p>格式<code>docker [container] commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</code>主要选项包括</p><p>-a,–author=”” 作者信息  </p><p>-c，–change=[] 提交时执行Dockerfile命令</p><p>-p,–pause=true执行时暂停是暂停容器运行</p></blockquote></li><li><p>演示：启动一个镜像，并在其中进行修改操作</p><pre><code>(docker) missj@  ~  docker run -it ubuntu:18.04 /bin/bash                                                ✔  297  12:02:06root@94b5b306ceba:/# touch testroot@94b5b306ceba:/# exitexit</code></pre></li><li><p>提交容器</p><pre><code> missj@  ~  docker container commit -m &quot;add a new file&quot; -a &quot;missj&quot; 94b5b306ceba test:0.1         ✔  303  12:16:14sha256:00d5fabda363bc043eb6a13d6c1d89b9417e1f94fdd020efd6ce86675d4bf180</code></pre></li><li><p>查看</p><pre><code class="linux"> missj@  ~  docker images                                                                        ✔  304  12:16:23REPOSITORY          TAG                 IMAGE ID            CREATED             SIZEtest                0.1                 00d5fabda363        20 seconds ago      86.2MBnginx               latest              568c4670fa80        3 weeks ago         109MBubuntu              18.04               93fd78260bd1        4 weeks ago         86.2MB missj@  ~ </code></pre></li><li><p>基于本地模板导入</p><blockquote><p>命令格式<code>docker [image] import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]</code></p></blockquote></li><li><p>演示OPENVZ模版下载，下载地址为(<a href="https://wiki.openvz.org/Download/template/precreated" target="_blank" rel="noopener">https://wiki.openvz.org/Download/template/precreated</a>)</p><pre><code> missj@  ~/Downloads  cat ubuntu-14.04-x86-minimal.tar.gz | docker import - ubuntu:14.04sha256:e1f1d8ba4d0ad4874c448de5e3d2013a225ed3debc6a78a570a5ca10a9f6f2ee</code></pre></li><li><p>基于Dockerfile创建创建</p></li></ul><h3 id="存出镜像-docker-save"><a href="#存出镜像-docker-save" class="headerlink" title="存出镜像[docker save]"></a>存出镜像[docker save]</h3><p>存出ubuntu:18.04到本地文件</p><pre><code>docker save -o ubuntu_18.04.tar ubuntu:18.04</code></pre><h3 id="载入镜像-docker-load"><a href="#载入镜像-docker-load" class="headerlink" title="载入镜像[docker load]"></a>载入镜像[docker load]</h3><p>将存出的tar文件导入到本地镜像库存</p><pre><code>docker load -i ubuntu_18.04.tar</code></pre><p>或</p><pre><code>docker load &lt; ubuntu_18.04.tar</code></pre><h3 id="上传镜像"><a href="#上传镜像" class="headerlink" title="上传镜像"></a>上传镜像</h3><p>默认上传到docker hub官方仓库，需要登录，命令行为<code>docker push NAME[:TAG] [REGISTRY_HOST[:REGISTRY_PORT]/]NAME[:TAG]</code></p><h3 id="查看docker支持的镜像支持子命令"><a href="#查看docker支持的镜像支持子命令" class="headerlink" title="查看docker支持的镜像支持子命令"></a>查看docker支持的镜像支持子命令</h3><p>docker image help</p><h2 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h2><ol><li>新建容器</li></ol><pre><code>docker create</code></pre><ol start="2"><li>启动容器</li></ol><pre><code>docker start</code></pre><ol start="3"><li>新建并启动容器</li></ol><pre><code>docker run`等价于先`docker create`再`docker start</code></pre><h3 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h3><ol><li><p>查看容器信息</p><p><code>docker ps或docker container ls</code></p></li><li><p>查看容器输出</p><pre><code>docker logs [OPTIONS] CONTAINER</code></pre><blockquote><p>OPTIONS:</p><ul><li>-detail 详细信息</li><li>-f,-follow 持续保持输出</li><li>-since string 输出从某个时间开始的日志</li><li>-tail string 输出最近的若干日志</li><li>-t,timestamps 显示时间戳信息</li><li>-until string 输出某个时间之前的日志</li></ul></blockquote></li></ol><h2 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h2><ol><li><p>暂停容器</p><pre><code>docker pause CONTAINER [CONTAINER...]</code></pre><p>恢复暂停的容器</p><p>docker unpause CONTAINER [CONTAINER…]</p></li><li><p>终止容器</p><p><code>docker stop [OPTIONS] CONTAINER [CONTAINER...]</code></p></li><li><p>重启容器</p><p><code>docker restart [OPTIONS] CONTAINER [CONTAINER...]</code></p></li></ol><h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><p>​    使用-d启动容器后，将会后台运行，这个时候进入容器需要<code>docker attach [OPTIONS] CONTAINER</code>或 </p><p>​    <code>docker exec [OPTIONS] CONTAINER COMMAND [ARG...]</code></p><blockquote><p>Options:</p><p>-d, –detach               Detached mode: run command in the background</p><p>–detach-keys string   Override the key sequence for detaching a container</p><p>-e, –env list             Set environment variables</p><p>-i, –interactive          Keep STDIN open even if not attached</p><p>–privileged           Give extended privileges to the command</p><p>-t, –tty                  Allocate a pseudo-TTY</p><p>-u, –user string          Username or UID (format: &lt;name|uid&gt;[:&lt;group|gid&gt;])</p><p>-w, –workdir string       Working directory inside the container</p></blockquote><h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h2><p><code>docker rm</code>删除处于终止或退出状态的容器</p><p><strong>## 导出容器</strong></p><pre><code>docker export -o CONTAINER</code></pre><h2 id="导入容器"><a href="#导入容器" class="headerlink" title="导入容器"></a>导入容器</h2><pre><code>docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]</code></pre><ol><li><p>查看容器内进程<code>docker top CONTAINER [ps OPTIONS]</code></p></li><li><p>查看当前运行中容器系统资源使用情况</p></li></ol><pre><code>docker ststs</code></pre><h3 id="容器操作命令"><a href="#容器操作命令" class="headerlink" title="容器操作命令"></a>容器操作命令</h3><ol><li>复制文件</li></ol><p>案例 本地data复制到/temp  </p><pre><code>docker cp data test:/tmp/</code></pre><ol start="2"><li>查看容器内数据变更</li></ol><p>案例： 查看test数据变更</p><pre><code>docker container diff test</code></pre><ol start="3"><li>查看端口映射</li></ol><p>查看test端口映射情况</p><pre><code>docker container port test</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux档案与目录管理</title>
      <link href="/2018/12/21/linux%E6%A1%A3%E6%A1%88%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"/>
      <url>/2018/12/21/linux%E6%A1%A3%E6%A1%88%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="相对路径与绝对路径"><a href="#相对路径与绝对路径" class="headerlink" title="相对路径与绝对路径"></a>相对路径与绝对路径</h2><p>绝对路径：路径的写法【一定由根目录/写起】<br>相对路径：路径的写法【不是由/写起】  </p><a id="more"></a><h2 id="目录的相关操作"><a href="#目录的相关操作" class="headerlink" title="目录的相关操作"></a>目录的相关操作</h2><p>. 代表当前目录<br>.. 代表上一层目录  </p><ul><li>代表前一个工作目录<br>～ 代表当前用户所在家目录<br>～account 代表account用户所在家目录  <h4 id="常见的处理目录指令"><a href="#常见的处理目录指令" class="headerlink" title="常见的处理目录指令"></a>常见的处理目录指令</h4>cd : 切换目录<br>pwd : 显示当前的目录<br>mkdir : 创建一个新的目录<br>rmdir : 删除一个空的目录<h6 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h6>pwd -P 显示正确的路径，而不会是链接路径<h6 id="mkdir-建立新的目录"><a href="#mkdir-建立新的目录" class="headerlink" title="mkdir(建立新的目录)"></a>mkdir(建立新的目录)</h6><code>mkdir [-mp] 目录名称</code>   </li><li>m 设定档案的权限    </li><li>p 创建多层目录  </li></ul><h6 id="rmdir"><a href="#rmdir" class="headerlink" title="rmdir"></a>rmdir</h6><p><code>rm [-p] 目录</code><br>-p 删除多层目录的空目录</p><h4 id="档案与目录的查看：ls"><a href="#档案与目录的查看：ls" class="headerlink" title="档案与目录的查看：ls"></a>档案与目录的查看：ls</h4><pre><code class="(linux)">[root@study ~]# ls [-aAdfFhilnrRSt] 文件或文件夹名称..[root@study ~]# ls [--color={never,auto,always}] 文件或文件夹名称..[root@study ~]# ls [--full-time] ..選項與參數：-a  ：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来常用)-A  ：全部的文件，连同隐藏文件，但不包括.和..-d  ：列出目录本身-f  ：直接列出结果，而不进行排序 (ls 默认用文件名排序！)-F  ：根据文件或目录，展示附加信息，例如：      *:代表可执行文件； /:代表目录； =:代表 socket 文件； |:代表 FIFO 文件；-h  ：将文件容量以易读的方式(例如 GB, KB 等等)列出來；-i  ：列出 inode 序号；-l  ：长资料传列出，包含文件的属性和权限；(常用)-n  ：列出 UID与GID 而非使用者与群組的名称-r  ：將排序結果反向輸出-R  ：子目录內容一起列出来-S  ：以文件容量大小排序，而不是用文件名排序；-t  ：时间排序--color=never  ：不显示颜色；--color=always ：显示顏色--color=auto   让系統自行根据设定來判斷是否給予顏色--full-time    ：以完整時間模式 (包含年、月、日、時、分) 輸出--time={atime,ctime} ：輸出 access 時間或改變權限屬性時間 (ctime)                        而非內容變更時間 (modification time)</code></pre><h4 id="复制、删除与移动cp、rm、mv"><a href="#复制、删除与移动cp、rm、mv" class="headerlink" title="复制、删除与移动cp、rm、mv"></a>复制、删除与移动cp、rm、mv</h4><h4 id="basename取文件名"><a href="#basename取文件名" class="headerlink" title="basename取文件名"></a>basename取文件名</h4><h4 id="dirname-取文件路径"><a href="#dirname-取文件路径" class="headerlink" title="dirname 取文件路径"></a>dirname 取文件路径</h4><h4 id="档案内容查看"><a href="#档案内容查看" class="headerlink" title="档案内容查看"></a>档案内容查看</h4><ul><li>cat 从第一行开始显示文件内容  </li><li>tac 从最后一行开始显示文件内容  </li><li>nl 显示的时候，输出行号</li><li>more 分页显示  </li><li>less 分页显示，可往前翻页</li><li>head 显示头几行</li><li>tail 显示尾几行</li><li>od 以二进制形式读取文件</li></ul><h4 id="搜索whereis、locate、find"><a href="#搜索whereis、locate、find" class="headerlink" title="搜索whereis、locate、find"></a>搜索whereis、locate、find</h4><pre><code>find [PATH] [option] [action]</code></pre>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 基础指令的操作</title>
      <link href="/2018/12/21/Linux-%E5%9F%BA%E7%A1%80%E6%8C%87%E4%BB%A4%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
      <url>/2018/12/21/Linux-%E5%9F%BA%E7%A1%80%E6%8C%87%E4%BB%A4%E7%9A%84%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux文字模式下指令"><a href="#Linux文字模式下指令" class="headerlink" title="Linux文字模式下指令"></a>Linux文字模式下指令</h2><h4 id="命令的基本格式"><a href="#命令的基本格式" class="headerlink" title="命令的基本格式"></a>命令的基本格式</h4><p> 基本格式<br> <a id="more"></a><br>commond [-option] parameter1 parameter2  </p><h4 id="基础指令的操作"><a href="#基础指令的操作" class="headerlink" title="基础指令的操作"></a>基础指令的操作</h4><p>显示日期的命令date  </p><pre><code>date</code></pre><p>运行结果</p><pre><code>2018年12月21日 星期五 11时06分41秒 CST</code></pre><h4 id="显示日历的指令cal"><a href="#显示日历的指令cal" class="headerlink" title="显示日历的指令cal"></a>显示日历的指令cal</h4><p>格式  </p><pre><code>cal [month] [year]</code></pre><p>执行命令  </p><pre><code>cal</code></pre><p>运行结果 </p><pre><code>      十二月 2018日 一 二 三 四 五 六                   1 2  3  4  5  6  7  8 9 10 11 12 13 14 1516 17 18 19 20 21 2223 24 25 26 27 28 29</code></pre><h2 id="linux档案权限概念"><a href="#linux档案权限概念" class="headerlink" title="linux档案权限概念"></a>linux档案权限概念</h2><p>ls -al显示档案的所有权限和属性信息  </p><pre><code>drwxr-xr-x   6 missj  staff    192 11 30 16:38 eclipse-workspace</code></pre><p>七个栏位分别代表档案类型权限、连接数、档案拥有者、档案所属群组、档案容量、档案最后被修改的时间、档名<br>一、第一栏代表这个档案的类型权限<br>接下来我们来介绍一下上面的drwxr-xr-x   </p><ul><li>第一个字母代表这个文件是【目录、文件、快捷方式等等】  </li></ul><ol><li>【d】为目录，即文件夹    </li><li>【-】为文件  </li><li>[l]软链，即快捷方式  </li><li>【b】可供储存的周边设备  </li><li>【c】序列号设备  </li></ol><ul><li>后九个字母，三个为一组，第一组为user的权限，第二组为group的权限，第三组为other的权限  </li></ul><h4 id="修改档案权限"><a href="#修改档案权限" class="headerlink" title="修改档案权限"></a>修改档案权限</h4><ul><li>chgrp ：改变档案所属群组</li><li>chown : 改变档案拥有者的</li><li>chmod : 修改档案权限  </li></ul><ol><li>数字类型修改档案权限<br>权限对应分数表【r：4；w：2；x：1】<br>demo【rwxr-xr-x对应着：755】<br>例如我们要给上面那个文件所有权限 则输入<code>chmod -R 777 eclipse-workspace</code>  </li><li>符号类型修改档案权限  </li></ol><ul><li>u代表用户</li><li>g代表组</li><li>o代表其他</li><li>a代表所有<br>demo【rwxr-xr-x对应着：u=wxr,go=rx】 </li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程安全</title>
      <link href="/2018/12/16/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
      <url>/2018/12/16/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="线程不安全"><a href="#线程不安全" class="headerlink" title="线程不安全"></a>线程不安全</h2><p>多个线程同时操作一个数据结构的时候产生了相互修改和串行的情况，没有保证数据的不一致性</p><a id="more"></a><pre><code class="(java)">public class NotSecuret {    public static void main(String[] args) {        Count count = new Count();        for (int i = 0; i &lt; 5; i++) {            User user = new User(count);            user.start();        }        try {            Thread.sleep(1000);        } catch (InterruptedException e) {            // TODO Auto-generated catch block            e.printStackTrace();        }        System.out.println(&quot;最后的值：&quot; + count.num);    }}class Count{    public int num = 0;    public void add() {        try {            // 模仿用户干活            Thread.sleep(51);        } catch (InterruptedException e) {            // TODO Auto-generated catch block            e.printStackTrace();        }        num++;        System.out.println(Thread.currentThread().getName() + &quot;-&quot; + num);    }}class User extends Thread{    private Count count;    public User(Count count) {        super();        this.count = count;    }    @Override    public void run() {        super.run();        count.add();    }}</code></pre><p>结果  </p><pre><code class="(result)">Thread-0-4Thread-2-4Thread-4-4Thread-3-4Thread-1-4最后的值：4</code></pre><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><pre><code class="(java)">public class Securet {    public static void main(String[] args) {        Count count = new Count();        for (int i = 0; i &lt; 5; i++) {            User user = new User(count);            user.start();        }        try {            Thread.sleep(1000);        } catch (InterruptedException e) {            // TODO Auto-generated catch block            e.printStackTrace();        }        System.out.println(&quot;最后的值：&quot; + count.num);    }}class Count{    public int num = 0;    public synchronized void  add() {        try {            // 模仿用户干活            Thread.sleep(51);        } catch (InterruptedException e) {            // TODO Auto-generated catch block            e.printStackTrace();        }        num++;        System.out.println(Thread.currentThread().getName() + &quot;-&quot; + num);    }}class User extends Thread{    private Count count;    public User(Count count) {        super();        this.count = count;    }    @Override    public void run() {        super.run();        count.add();    }}</code></pre><p>结果  </p><pre><code class="(result)">Thread-0-1Thread-4-2Thread-2-3Thread-1-4Thread-3-5最后的值：5</code></pre><p>实现线程的大致三种方法：  </p><ol><li>多实例</li><li>使用java.util.concurrent下面的类库</li><li>使用锁机制synchoronized、lock方法</li></ol><h3 id="隐示锁，又称线程同步synchoronized"><a href="#隐示锁，又称线程同步synchoronized" class="headerlink" title="隐示锁，又称线程同步synchoronized"></a>隐示锁，又称线程同步synchoronized</h3><p>用来修饰一个方法或一个代码块，保证在同一个时刻最多只有一个线程执行这段代码</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 编程 </tag>
            
            <tag> 并发 </tag>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程</title>
      <link href="/2018/12/16/%E7%BA%BF%E7%A8%8B/"/>
      <url>/2018/12/16/%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><strong># 线程</strong></p><p>线程是程序中的执行线程，Java虚拟机允许应用程序并发的运行多个执行程序。每个线程都有一个优先级，高优先级的线程的执行优先于低优先级线程</p><h3 id="线程简单实现的三种方式"><a href="#线程简单实现的三种方式" class="headerlink" title="线程简单实现的三种方式"></a>线程简单实现的三种方式</h3><ol><li><p>extend Thread 覆盖run方法</p><pre><code class="java">/** \*  \* @author missj \* @Description 1. extend Thread 覆盖run方法 * */public class Thread1 extends Thread {</code></pre></li></ol><p>   ​    @Override</p><p>   ​    public void run() {</p><p>   ​        super.run();</p><p>   ​        </p><p>   ​        try {</p><p>   ​            // 模拟做事情执行了500ms</p><p>   ​            Thread.sleep(500L);</p><p>   ​        } catch (InterruptedException e) {</p><p>   ​            // TODO Auto-generated catch block</p><p>   ​            e.printStackTrace();</p><p>   ​        }</p><p>   ​        System.out.println(“这是线程A” + new Date());</p><p>   ​    }</p><p>   ​    </p><p>   ​    </p><p>   ​    public static void main(String[] args) {</p><p>   ​        Thread1 thread1 = new Thread1();</p><p>   ​        thread1.start();</p><p>   ​        System.out.println(“这是主线程” + new Date());</p><p>   ​    }</p><p>   }</p><pre><code>   这种方法的缺点是extend只能继承一个父类  2. 实现Runnable接口，实现run方法</code></pre><p>   import java.util.Date;</p><p>   public class Thread2 implements Runnable {</p><p>   ​    @Override</p><p>   ​    public void run() {</p><p>   ​        try {</p><p>   ​            // 模拟做事情执行了500ms</p><p>   ​            Thread.sleep(500L);</p><p>   ​        } catch (InterruptedException e) {</p><p>   ​            // TODO Auto-generated catch block</p><p>   ​            e.printStackTrace();</p><p>   ​        }</p><p>   ​        System.out.println(“这是线程A” + new Date());</p><p>   ​    }</p><p>   ​    </p><p>   ​    public static void main(String[] args) {</p><p>   ​        Thread2 thread2 = new Thread2();</p><p>   ​        // 注意启动方式有点不一样</p><p>   ​        new Thread(thread2).start();</p><p>   ​        System.out.println(“这是主线程” + new Date());</p><p>   ​    }<br>   }</p><pre><code>3.  继承Callable，实现call方法，可以得到线程的执行结果   ```java   import java.util.concurrent.Callable;   import java.util.concurrent.ExecutionException;   import java.util.concurrent.FutureTask;   public class Threads3 {   ​    public static void main(String[] args) {   ​        TheadMain thread = new TheadMain();   ​        FutureTask&lt;String&gt; futureTask = new FutureTask&lt;&gt;(thread);   ​        new Thread(futureTask).start();   ​        System.out.println(&quot;this is main task&quot;);   ​        try {   ​            System.out.println(&quot;得到的返回结果是&quot; + futureTask.get());   ​        } catch (InterruptedException e) {   ​            // TODO Auto-generated catch block   ​            e.printStackTrace();   ​        } catch (ExecutionException e) {   ​            // TODO Auto-generated catch block   ​            e.printStackTrace();   ​        }   ​    }   }   class TheadMain implements Callable&lt;String&gt; {   ​    @Override   ​    public String call() throws Exception {   ​        // 模拟事情做了500ms   ​        Thread.sleep(500);   ​        System.out.println(&quot;this is thread B&quot;);   ​        return &quot;thread B&quot;;   ​    }   }</code></pre><h3 id="线程中断的方法"><a href="#线程中断的方法" class="headerlink" title="线程中断的方法"></a>线程中断的方法</h3><ol><li><p>Thread.stop()  </p><p>不安全，不建议使用</p></li><li><p>Thread.interrupt()</p></li></ol><h3 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h3><p>五个状态new、start、running、blocked、dead</p><h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><blockquote><p>后台运行线程。进程结束，守护线程结束，必须在启动线程前调用setDaemon(true)，才能将它设置为守护线程</p></blockquote><pre><code class="java">public class ThreadMain {​    public static void main(String[] args) {​        ThreadA threadA = new ThreadA();​        ThreadB threadB = new ThreadB();​        threadB.setDaemon(true);​        threadA.start();​        threadB.start();​        Thread mainThread = Thread.currentThread();​        System.out.println(&quot;线程A是是否是守护线程&quot; + threadA.isDaemon());​        System.out.println(&quot;线程B是是否是守护线程&quot; + threadB.isDaemon());​        System.out.println(&quot;线程main是是否是守护线程&quot; + mainThread.isDaemon());​    }​    }class ThreadA extends Thread{​    @Override​    public void run() {​        super.run();​        for (int i = 0; i &lt; 5; i++) {​            System.out.println(&quot;Thread A run&quot; + i + &quot;times&quot;);​            try {​                Thread.sleep(7);​            } catch (InterruptedException e) {​                // TODO Auto-generated catch block​                e.printStackTrace();​            }​        }​    }}class ThreadB extends Thread{​    @Override​    public void run() {​        // TODO Auto-generated method stub​        super.run();​        for (int i = 0; i &lt; 9999L; i++) {​            System.out.println(&quot;Thread B run&quot; + i + &quot;times&quot;);​            try {​                Thread.sleep(7);​            } catch (InterruptedException e) {​                // TODO Auto-generated catch block​                e.printStackTrace();​            }​        }​    }}</code></pre><p>运行结果</p><pre><code>Thread A run0timesThread B run0times线程A是是否是守护线程false线程B是是否是守护线程true线程main是是否是守护线程falseThread A run1timesThread B run1timesThread A run2timesThread B run2timesThread A run3timesThread B run3timesThread B run4timesThread A run4timesThread B run5times</code></pre><p>从以上，可以发现，前台线程一旦结束，守护线程就退出了</p><h3 id="当前线程副本：ThreadLocal"><a href="#当前线程副本：ThreadLocal" class="headerlink" title="当前线程副本：ThreadLocal"></a>当前线程副本：ThreadLocal</h3><ol><li><p>当用ThreadLocal维护变量时，ThradLocal为每个使用该变量的线程提供独立的线程副本</p></li><li><p>ThreadLocal<t>下的主要方法</t></p><pre><code>/**​     \* Returns the current thread&#39;s &quot;initial value&quot; for this​     \* thread-local variable.  This method will be invoked the first​     \* time a thread accesses the variable with the {@link #get}​     \* method, unless the thread previously invoked the {@link #set}​     \* method, in which case the {@code initialValue} method will not​     \* be invoked for the thread.  Normally, this method is invoked at​     \* most once per thread, but it may be invoked again in case of​     \* subsequent invocations of {@link #remove} followed by {@link #get}.​     *​     \* &lt;p&gt;This implementation simply returns {@code null}; if the​     \* programmer desires thread-local variables to have an initial​     \* value other than {@code null}, {@code ThreadLocal} must be​     \* subclassed, and this method overridden.  Typically, an​     \* anonymous inner class will be used.​     *​     \* @return the initial value for this thread-local​     */​    protected T initialValue() {​        return null;​    }</code></pre><pre><code>/**​     \* Returns the value in the current thread&#39;s copy of this​     \* thread-local variable.  If the variable has no value for the​     \* current thread, it is first initialized to the value returned​     \* by an invocation of the {@link #initialValue} method.​     *​     \* @return the current thread&#39;s value of this thread-local​     */​    public T get() {​        Thread t = Thread.currentThread();​        ThreadLocalMap map = getMap(t);​        if (map != null) {​            ThreadLocalMap.Entry e = map.getEntry(this);​            if (e != null) {​                @SuppressWarnings(&quot;unchecked&quot;)​                T result = (T)e.value;​                return result;​            }​        }​        return setInitialValue();​    }</code></pre><pre><code>/**​     \* Sets the current thread&#39;s copy of this thread-local variable​     \* to the specified value.  Most subclasses will have no need to​     \* override this method, relying solely on the {@link #initialValue}​     \* method to set the values of thread-locals.​     *​     \* @param value the value to be stored in the current thread&#39;s copy of​     \*        this thread-local.​     */​    public void set(T value) {​        Thread t = Thread.currentThread();​        ThreadLocalMap map = getMap(t);​        if (map != null) {​            map.set(this, value);​        } else {​            createMap(t, value);​        }​    }</code></pre><pre><code> /**​     \* Removes the current thread&#39;s value for this thread-local​     \* variable.  If this thread-local variable is subsequently​     \* {@linkplain #get read} by the current thread, its value will be​     \* reinitialized by invoking its {@link #initialValue} method,​     \* unless its value is {@linkplain #set set} by the current thread​     \* in the interim.  This may result in multiple invocations of the​     \* {@code initialValue} method in the current thread.​     *​     \* @since 1.5​     */​     public void remove() {​         ThreadLocalMap m = getMap(Thread.currentThread());​         if (m != null) {​             m.remove(this);​         }​     }</code></pre><ol start="3"><li>简单使用</li></ol><pre><code>public class ThreadLocalDemo {​    // 通过匿名内部类覆盖initialValue(),指定初始指​    private static ThreadLocal&lt;Integer&gt; threadLocal = new ThreadLocal&lt;Integer&gt;() {​        @Override​        protected Integer initialValue() {​            // TODO Auto-generated method stub​            return 0;​        }​    };</code></pre></li></ol><p>   ​    public static ThreadLocal<integer> getThreadLocal() {</integer></p><p>   ​        return threadLocal;</p><p>   ​    }</p><p>   ​    /**</p><p>   ​     * 获取下一个序列值</p><p>   ​     * @return</p><p>   ​     */</p><p>   ​    public int getNextNum() {</p><p>   ​        threadLocal.set(threadLocal.get() + 1);</p><p>   ​        return threadLocal.get();</p><p>   ​    }</p><p>   ​    </p><p>   ​    private static class ThreadClient extends Thread{</p><p>   ​        private ThreadLocalDemo sn;</p><p>   ​        public ThreadClient(ThreadLocalDemo sn) {</p><p>   ​            super();</p><p>   ​            this.sn = sn;</p><p>   ​        }</p><p>   ​        </p><p>   ​        @Override</p><p>   ​        public void run() {</p><p>   ​            super.run();</p><p>   ​            for (int i = 0; i &lt; 3; i++) {</p><p>   ​                // 每个线程打出三个序列号</p><p>   ​                System.out.println(“thread” + Thread.currentThread().getName() + “&gt;&gt;” + sn.getNextNum());</p><p>   ​            }</p><p>   ​            // 每个线程用完记得移除 </p><p>   ​            sn.getThreadLocal().remove();</p><p>   ​        }</p><p>   ​    }</p><p>   ​    </p><p>   ​    public static void main(String[] args) {</p><p>   ​        ThreadLocalDemo threadLocalDemo = new ThreadLocalDemo();</p><p>   ​        ThreadClient threadClient1 = new ThreadClient(threadLocalDemo);</p><p>   ​        ThreadClient threadClient2 = new ThreadClient(threadLocalDemo);</p><p>   ​        ThreadClient threadClient3 = new ThreadClient(threadLocalDemo);</p><p>   ​        threadClient1.start();</p><p>   ​        threadClient2.start();</p><p>   ​        threadClient3.start();</p><p>   ​    }</p><p>   ​    </p><p>   }</p><pre><code>   结果</code></pre><p>   threadThread-0&gt;&gt;1</p><p>   threadThread-0&gt;&gt;2</p><p>   threadThread-1&gt;&gt;1</p><p>   threadThread-0&gt;&gt;3</p><p>   threadThread-2&gt;&gt;1</p><p>   threadThread-1&gt;&gt;2</p><p>   threadThread-2&gt;&gt;2</p><p>   threadThread-1&gt;&gt;3</p><p>   threadThread-2&gt;&gt;3</p><pre><code>   每个线程虽然都共享了ThreadLocalDemo实例，但并为相互影响，这是因为用ThreadLocal为每个线程提供了单独的副本   4. 注意   使用ThreadLocal，一般是申明在静态变量中，如果不断的创建，而没有调用remove()方法，将会导致内存泄漏### 线程异常的处理1. run()方法不允许throw Exception,所有的异常必须在run方法内进行处理（try catch）2. 对于unchecked exception，比较合理的一个方法是注册一个实现UncaughtExceptionHandler接口的对象实例来处理</code></pre><p>import java.lang.Thread.UncaughtExceptionHandler;</p><p>public class ThreadExceptionDemo {</p><p>​    public static void main(String[] args) {</p><p>​        ThreadB threadB = new ThreadB();</p><p>​        Thread thread = new Thread(threadB);</p><p>​        thread.setUncaughtExceptionHandler(new ExceptionHandlerThreadB());</p><p>​        thread.start();</p><p>​    }</p><p>}</p><p>class ExceptionHandlerThreadB implements UncaughtExceptionHandler{</p><p>​    @Override</p><p>​    public void uncaughtException(Thread t, Throwable e) {</p><p>​        System.out.println(“an exception has been captured\n”);</p><p>​        System.out.printf(“Thread:%s\n”,t.getId());</p><p>​        System.out.printf(“Exception: %s: %s\n”,e.getClass().getName(), e.getMessage());</p><p>​        System.out.println(“stack trace: \n”);</p><p>​        e.printStackTrace(System.out);</p><p>​        System.out.printf(“Thread status: %s\n”, t.getState());</p><p>​    }</p><p>​    </p><p>}</p><p>class ThreadB extends Thread{</p><p>​    @Override</p><p>​    public void run() {</p><p>​        // TODO Auto-generated method stub</p><p>​        super.run();</p><p>​        int number0 = Integer.parseInt(“TTT”);</p><p>​    }</p><p>}</p><pre><code>结果</code></pre><p>an exception has been captured</p><p>Thread:12</p><p>Exception: java.lang.NumberFormatException: For input string: “TTT”</p><p>stack trace: </p><p>java.lang.NumberFormatException: For input string: “TTT”</p><p>​    at java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)</p><p>​    at java.base/java.lang.Integer.parseInt(Integer.java:652)</p><p>​    at java.base/java.lang.Integer.parseInt(Integer.java:770)</p><p>​    at ThreadB.run(ThreadExceptionDemo.java:32)</p><p>​    at java.base/java.lang.Thread.run(Thread.java:834)</p><p>Thread status: RUNNABLE<br>```</p><p><a href="https://gitee.com/missj/thread" target="_blank" rel="noopener">源码地址</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 编程 </tag>
            
            <tag> 并发 </tag>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程与并发</title>
      <link href="/2018/12/16/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
      <url>/2018/12/16/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="线程于并发"><a href="#线程于并发" class="headerlink" title="线程于并发"></a>线程于并发</h1><h3 id="线程与进程进行对比"><a href="#线程与进程进行对比" class="headerlink" title="线程与进程进行对比"></a>线程与进程进行对比</h3><table><thead><tr><th align="left"></th><th align="right">进程</th><th align="right">线程</th></tr></thead><tbody><tr><td align="left">定义</td><td align="right">进程是程序运行的一个实体的运行过程，是系统进行资源分配和调度的一个独立单位</td><td align="right">线程是进程运行和执行的最小调度单位</td></tr><tr><td align="left">活泼性</td><td align="right">不活泼（线程的容器）</td><td align="right">活泼，随时可以创建和销毁</td></tr><tr><td align="left">拥有资源</td><td align="right">资源拥有的基本单位</td><td align="right">相对于进程来说基本上不拥有资源，但会占用CPU</td></tr><tr><td align="left">地址空间</td><td align="right">系统赋予的独立的内存地址空间</td><td align="right">线程只由相关堆栈寄存器和线程控制表TCB组成，寄存器可被用来存储线程内的局部变量</td></tr><tr><td align="left">调度</td><td align="right">仅是资源分配的基本单位</td><td align="right">独立调度、分派的基本单位</td></tr><tr><td align="left">安全性</td><td align="right">进程之间相对独立，基本不会影响</td><td align="right">线程共享同一个进程下的资源，可以相互通信和影响</td></tr></tbody></table><a id="more"></a><h3 id="并行运行"><a href="#并行运行" class="headerlink" title="并行运行"></a>并行运行</h3><ol><li>线程同时所开启的运行中的线程数， &lt;=CPU数量*CPU的核心数量  </li><li>线程同时所开启的运行中的线程数， &lt;=CPU数量*CPU的线程数量</li></ol><h3 id="并发运行-单位时间并发量"><a href="#并发运行-单位时间并发量" class="headerlink" title="并发运行(单位时间并发量)"></a>并发运行(单位时间并发量)</h3><ol><li>线程同时所开启的运行中的线程数， &gt;CPU数量*CPU的核心数量  </li><li>线程同时所开启的运行中的线程数， &gt;CPU数量*CPU的线程数量</li></ol><h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><p>网络、设备、端口、虚电路和其他设施，单位时间内成功传送数据的数量</p><h3 id="高并发编程优点"><a href="#高并发编程优点" class="headerlink" title="高并发编程优点"></a>高并发编程优点</h3><ol><li>充分利用CPU资源</li><li>加快响应用户的时间</li><li>可以使代码模块化、异步化、简单化</li></ol><h3 id="高并发编程缺点"><a href="#高并发编程缺点" class="headerlink" title="高并发编程缺点"></a>高并发编程缺点</h3><ol><li>线程安全</li><li>线程之间的死循环</li><li>过多线程会将服务器资源耗尽形成死机宕机</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 编程 </tag>
            
            <tag> 并发 </tag>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合</title>
      <link href="/2018/12/13/%E9%9B%86%E5%90%88/"/>
      <url>/2018/12/13/%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p><img src="//wanmisy.github.io/2018/12/13/集合/QQ20181213-0.JPG" alt="Java集合框架图"><br>备注：红色为接口，蓝色为抽象类，绿色代表并发包中的类，灰色代表早期线程安全的类（基本已经弃用）</p><a id="more"></a><h3 id="List-extends-Collection-集合"><a href="#List-extends-Collection-集合" class="headerlink" title="List(extends Collection)集合"></a>List(extends Collection)集合</h3><blockquote><p>线性数据结构的主要实现，通常存在明确的上一个和下一个元素，也存在明确的第一个和最后一个元素。该类最常用的是ArrayList和LinkedList</p></blockquote><h5 id="ArrayList-extends-AbstractList-implements-List-RandomAccess-Cloneable-java-io-Serializable"><a href="#ArrayList-extends-AbstractList-implements-List-RandomAccess-Cloneable-java-io-Serializable" class="headerlink" title="ArrayList(extends AbstractList implements List, RandomAccess, Cloneable, java.io.Serializable)"></a>ArrayList(extends AbstractList<e> implements List<e>, RandomAccess, Cloneable, java.io.Serializable)</e></e></h5><p>可以改变的非线程安全集合，默认大小是10   </p><pre><code>/**     * Appends the specified element to the end of this list.     *     * @param e element to be appended to this list     * @return &lt;tt&gt;true&lt;/tt&gt; (as specified by {@link Collection#add})     */    public boolean add(E e) {        ensureCapacityInternal(size + 1);  // Increments modCount!!        elementData[size++] = e;        return true;    }</code></pre><p>通过看源码，可以看ArrayList是通过数组来进行存储的，不给长度的时候，默认值大小是10，集合添加元素时，会通过新建size++的数组，将原油数据拷贝到新的数组来实现，因此支持通过下标来访问元素，但是插入和删除的速度非常慢，因为这个过程是通过数组扩容来实现，因此很有可能要移动其他元素。  </p><h5 id="LinkedList-extends-AbstractSequentialList-implements-List-Deque-Cloneable-java-io-Serializable"><a href="#LinkedList-extends-AbstractSequentialList-implements-List-Deque-Cloneable-java-io-Serializable" class="headerlink" title="LinkedList(extends AbstractSequentialList implements List, Deque, Cloneable, java.io.Serializable)"></a>LinkedList(extends AbstractSequentialList<e> implements List<e>, Deque<e>, Cloneable, java.io.Serializable)</e></e></e></h5><p>本质是双向链表，插入和删除速度快，但是随机访问速度慢  </p><h3 id="Queue-extends-Collection-集合"><a href="#Queue-extends-Collection-集合" class="headerlink" title="Queue(extends Collection)集合"></a>Queue(extends Collection)集合</h3><p>先进先出的数据结构，只允许在表的一端进行获取操作，在另一端进行插入操作</p><h3 id="Set（extends-Collection）"><a href="#Set（extends-Collection）" class="headerlink" title="Set（extends Collection）"></a>Set（extends Collection）</h3><p>不允许出现重复元素的集合，且最多一个null元素</p><h5 id="SortedSet（extends-Set）"><a href="#SortedSet（extends-Set）" class="headerlink" title="SortedSet（extends Set）"></a>SortedSet（extends Set）</h5><h3 id="Map（Interface）"><a href="#Map（Interface）" class="headerlink" title="Map（Interface）"></a>Map（Interface）</h3><p>以key-value键值对作为存储元素实现的哈希结构,有唯一的key，每一个key都至少有一个value，取代了旧的抽象类Dictionary,拥有更好的性能。Map提供了三种collection视图<br><img src="//wanmisy.github.io/2018/12/13/集合/WX20181213-180037@2x.png" alt="Map集合"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 编程 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>悲观锁和乐观锁</title>
      <link href="/2018/12/12/%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81/"/>
      <url>/2018/12/12/%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="悲观锁和乐观锁"><a href="#悲观锁和乐观锁" class="headerlink" title="悲观锁和乐观锁"></a>悲观锁和乐观锁</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;在介绍悲观锁和乐观锁之前,我们先看一下一个案例，简单介绍一下超反现象。  </p><a id="more"></a><h2 id="超反现象案例"><a href="#超反现象案例" class="headerlink" title="超反现象案例"></a>超反现象案例</h2><pre><code>eg：购买产品</code></pre><pre><code class="（mysql）">CREATE TABLE `product` (  `id` int(11) NOT NULL AUTO_INCREMENT,  `name` varchar(60) DEFAULT NULL COMMENT &#39;名称&#39;,  `stock` int(10) DEFAULT NULL COMMENT &#39;库存&#39;,  `price` decimal(16,2) DEFAULT NULL COMMENT &#39;单价&#39;,  `version` int(10) DEFAULT NULL COMMENT &#39;版本&#39;,  PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;</code></pre><pre><code class="(mysql)">CREATE TABLE `orders` (  `id` int(11) NOT NULL AUTO_INCREMENT,  `userId` int(10) DEFAULT NULL COMMENT &#39;用户编号&#39;,  `productId` int(10) DEFAULT NULL COMMENT &#39;产品编号&#39;,  `price` decimal(16,2) DEFAULT NULL COMMENT &#39;单价&#39;,  `number` int(10) DEFAULT NULL COMMENT &#39;数量&#39;,  `totalPrice` decimal(16,2) DEFAULT NULL COMMENT &#39;总价&#39;,  `order_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#39;购买时间&#39;,  PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=55 DEFAULT CHARSET=utf8;</code></pre><p>核心代码</p><pre><code class="（java）">@Override    @Transactional    public boolean purchase(int userId, int productId, int num) {        // 无锁        ProductModel model = productService.getById(productId);        if (model == null){            // 无该产品            return false;        } else {            if (model.getStock() &lt; num){                // 库存不足                return false;            }            // 修改库存            boolean des = productService.decreaseProduct(model.getId(), num);            // 初始化购买记录            if (des){                OrderModel orderModel = new OrderModel();                orderModel.setUserId(userId);                orderModel.setNumber(num);                orderModel.setPrice(model.getPrice());                orderModel.setTotalPrice(model.getPrice().multiply(new BigDecimal(num)));                orderModel.setProductId(productId);                orderModel.setOrderTime(LocalDateTime.now());                boolean bo = super.save(orderModel);                if (bo){                    // 购买成功                    return true;                }            }        }        return false;    }</code></pre><p>js购买：</p><pre><code class="(javascript)">$(&quot;#purchase&quot;).click(function(){                var params = {                    userId: 1,                    productId: 1,                    num: 1                };                // 通过POST请求后端，这里的JavaScript会采用异步请求                $.post(&quot;http://localhost:8080/product/order-model/purchase&quot;, params, function (result) {                    console.log(result.message)                });            })</code></pre><p>测试结果：<br><img src="/%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81/WX20181212-150118@2x.png" alt="test"></p><p>然而很多时候，在抢购的时候，都会出现并发，这里我们用简单的JS来做模拟</p><pre><code class="(javascript)">$(&quot;#purchase&quot;).click(function(){                for (var i=1; i&lt;=1000; i++) {                    var params = {                        userId: 1,                        productId: 1,                        num: 1                    };                    // 通过POST请求后端，这里的JavaScript会采用异步请求                    $.post(&quot;http://localhost:8080/product/order-model/purchase&quot;, params, function (result) {                        console.log(result.message)                    });                }            })</code></pre><p>测试之前，我们看一下库存<br><img src="//wanmisy.github.io/2018/12/12/悲观锁和乐观锁/WX20181212-151022@2x.png" alt="stock"><br>测试结果<br><img src="//wanmisy.github.io/2018/12/12/悲观锁和乐观锁/WX20181212-151631@2x.png" alt="test result"><br>这个时候的库存<br><img src="//wanmisy.github.io/2018/12/12/悲观锁和乐观锁/WX20181212-151756@2x.png" alt="test stock"></p><pre><code class="(SQL)">SELECT MIN(order_time),MAX(order_time),COUNT(1) FROM orders WHERE productId = 1;</code></pre><p><img src="//wanmisy.github.io/2018/12/12/悲观锁和乐观锁/WX20181212-180320@2x.png" alt="test result"><br>可以看到产品表的库存库存从500变到了-1，插入了501条订单。500件商品，却卖出了501件，什么原因呢？这就是超反现象。我们来分析一下  </p><table><thead><tr><th align="left">时刻</th><th align="right">线程1</th><th align="center">线程2</th><th align="center">备注</th></tr></thead><tbody><tr><td align="left">T1</td><td align="right">读取库存为1</td><td align="center"></td><td align="center">可购买</td></tr><tr><td align="left">T2</td><td align="right"></td><td align="center">读取库存为1</td><td align="center">可购买</td></tr><tr><td align="left">T3</td><td align="right">扣减库存</td><td align="center"></td><td align="center">库存为0</td></tr><tr><td align="left">T4</td><td align="right"></td><td align="center">扣减库存</td><td align="center">库存为-1、</td></tr><tr><td align="left">T5</td><td align="right">读取库存为-1</td><td align="center"></td><td align="center">库存不足，不可购买</td></tr></tbody></table><p>为了解决高并发时的超发现象，企业级开发提出了悲观锁、乐观锁和Redis等多种方案。</p><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><blockquote><p>具有强烈的独占和排他特性。它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。</p></blockquote><h4 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h4><p>1.在对任意记录进行修改前，先尝试为该记录加上排他锁（exclusive locking）<br>2.如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常<br>3.如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了<br>4.其间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常</p><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><p>select…for update</p><p>依然是对上面的例子我们做一个修改</p><pre><code>@Select(&quot;select  * from product where id = #{productId} for update&quot;)    ProductModel selectModelById(int productId);</code></pre><p><img src="//wanmisy.github.io/2018/12/12/悲观锁和乐观锁/WX20181212-180032@2x.png" alt="悲观锁结果"><br>这个时候我们可以看到，数据是正常了，但是加锁比加锁时，性能降低了</p><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><blockquote><p>大多是基于数据版本（ Version ）记录机制实现。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。</p></blockquote><p><img src="//wanmisy.github.io/2018/12/12/悲观锁和乐观锁/WX20181212-183019@2x.png" alt="乐观锁结果"><br>从数据结果我们可以看到，解决了超反问题，因为没有独占资源和阻塞任何线程的并发，所以乐观锁也称为非独占锁或无阻塞锁但是出现了大量购买失败的数据。接下来我们需要解决这个问题，在更新库存失败的时候，尝试重新请求，但是这样就增加了吞吐量。可以采用，在某一时间范围内失败了，就重复请求，或者重试指定次数。由于时间来重入，不确定性太大，建议使用次数限制</p><pre><code class="(java)">@Override    @Transactional    public boolean purchase(int userId, int productId, int num) {        for (int i=0; i &lt; 3; i++){            // 无锁            ProductModel model = productService.getById(productId);            // 乐观锁            //ProductModel model = productService.selectModelById(productId);            if (model == null){                // 无该产品                return false;            } else {                if (model.getStock() &lt; num){                    // 库存不足                    return false;                }                // 修改库存                //productService.decreaseProduct(model.getId(), num);                boolean des = productService.decreaseProduct2(model.getId(), num, model.getVersion());                // 初始化购买记录                if (des){                    OrderModel orderModel = new OrderModel();                    orderModel.setUserId(userId);                    orderModel.setNumber(num);                    orderModel.setPrice(model.getPrice());                    orderModel.setTotalPrice(model.getPrice().multiply(new BigDecimal(num)));                    orderModel.setProductId(productId);                    orderModel.setOrderTime(LocalDateTime.now());                    boolean bo = super.save(orderModel);                    if (bo){                        // 购买成功                        return true;                    }                }            }        }        return false;    }</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 编程 </tag>
            
            <tag> 并发 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/2018/10/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2018/10/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><blockquote><p>数据结构指的是数据在计算机内存空间中或磁盘中的组织形式</p></blockquote><a id="more"></a>   <table><thead><tr><th>数据结构</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>数组</td><td>插入快，通过数组下标可以非常快的存取</td><td>查找慢、删除慢、大小固定</td></tr><tr><td>有序数组</td><td>比无序数组查找快</td><td>插入慢、删除慢、大小固定</td></tr><tr><td>栈</td><td>后进先出</td><td>存取其他项很慢</td></tr><tr><td>队列</td><td>先进先出</td><td>存取其他项很慢</td></tr><tr><td>链表</td><td>删除快、插入快</td><td>查找慢</td></tr><tr><td>二叉树</td><td>插入、查找、删除都快</td><td>删除算法复杂</td></tr><tr><td>红黑树</td><td>插入、查找、删除都快</td><td>算法复杂</td></tr><tr><td>2-3-4树</td><td>插入、查找、删除都快</td><td>算法复杂</td></tr><tr><td>哈希表</td><td>已知关键字的情况下，存取极快</td><td>删除慢，未知关键字的情况下，存取也特别慢，对存储空间使用不充分</td></tr><tr><td>堆</td><td>插入删除快，对最大数据项的存取很快</td><td>对其他数据项存取慢</td></tr><tr><td>图</td><td>对实现世界建模</td><td>有些算法慢且复杂</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 编程 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令模式</title>
      <link href="/2018/10/18/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/10/18/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>将一个请求封装成对象，从而使您可以用不同的请求对客户进行参数化</p><a id="more"></a><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>降低了系统耦合度</li><li>新的命令可以很容易添加到系统中去</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>使用命令模式可能会导致某些系统有过多的具体命令类。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代理模式</title>
      <link href="/2018/10/18/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/10/18/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>为其他对象提供一种代理以控制对这个对象的访问</p><a id="more"></a><h2 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h2><p>spring aop</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>职责清晰</li><li>高扩展性</li><li>智能化</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。</li><li>实现代理模式需要额外的工作，有些代理模式的实现非常复杂。</li></ul><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li>和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。</li><li>和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。</li></ul><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><pre><code>public interface Image {    void display();}</code></pre><pre><code>public class ProxyImage implements Image {    private RealImage realImage;       private String fileName;       public ProxyImage(String fileName){          this.fileName = fileName;       }       @Override       public void display() {          if(realImage == null){             realImage = new RealImage(fileName);          }          realImage.display();       }}</code></pre><pre><code>public class RealImage implements Image {    private String fileName;    public RealImage(String fileName) {        this.fileName = fileName;        loadFromDisk(fileName);    }    @Override    public void display() {        System.out.println(&quot;Displaying &quot; + fileName);    }    private void loadFromDisk(String fileName){          System.out.println(&quot;Loading &quot; + fileName);       }}</code></pre><pre><code>public class Test {    public static void main(String[] args) {        Image image = new ProxyImage(&quot;test_10mb.jpg&quot;);        // 图像将从磁盘加载        image.display();        System.out.println(&quot;&quot;);        // 图像不需要从磁盘加载        image.display();    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>享元模式</title>
      <link href="/2018/10/18/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/10/18/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p>运用共享技术有效的支持大量细粒度的对象，主要用于减少创建对象的数量，以减少内存占用和提高性能，属于结构型模式。提供了减少对象数量从而改善应用所需的对象结构的方式</p><a id="more"></a><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul><li>系统有大量相似对象</li><li>需要缓冲池的场景</li></ul><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>大大减少对象的创建，降低系统的内存，使效率提高</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>提高了系统的复杂度，需要分理出外部状态和内部状态，否则可能会引起线程安全问题</li><li>这些类必须有一个工厂对象加以控制</li></ul><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><pre><code>public interface Shape {    void draw();}</code></pre><pre><code>public class Circle implements Shape {    private String color;    private int x;    private int y;    private int radius;    public Circle(String color) {        this.color = color;    }    public void setX(int x) {        this.x = x;    }    public void setY(int y) {        this.y = y;    }    public void setRadius(int radius) {        this.radius = radius;    }    @Override    public void draw() {        // TODO Auto-generated method stub    }}</code></pre><pre><code>import java.util.HashMap;public class ShapeFactory {    private static final HashMap&lt;String, Shape&gt; circleMap = new HashMap&lt;&gt;();    public static Shape getCircle(String color) {          Circle circle = (Circle)circleMap.get(color);          if(circle == null) {             circle = new Circle(color);             circleMap.put(color, circle);             System.out.println(&quot;Creating circle of color : &quot; + color);          }          return circle;       }}</code></pre><pre><code>public class Test {    private static final String colors[] = { &quot;Red&quot;, &quot;Green&quot;, &quot;Blue&quot;, &quot;White&quot;, &quot;Black&quot; };    private static String getRandomColor() {        return colors[(int) (Math.random() * colors.length)];    }    private static int getRandomX() {        return (int) (Math.random() * 100);    }    private static int getRandomY() {        return (int) (Math.random() * 100);    }    public static void main(String[] args) {        for (int i = 0; i &lt; 20; ++i) {            Circle circle = (Circle) ShapeFactory.getCircle(getRandomColor());            circle.setX(getRandomX());            circle.setY(getRandomY());            circle.setRadius(100);            circle.draw();        }    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>外观模式</title>
      <link href="/2018/10/18/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/10/18/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><p>外观模式（Facade）,他隐藏了系统的复杂性，并向客户端提供了一个可以访问系统的接口。这种类型的设计模式属于结构性模式。为子系统中的一组接口提供了一个统一的访问接口，这个接口使得子系统更容易被访问或者使用。</p><a id="more"></a><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul><li>客户端不需要知道系统内部的复杂联系，整个系统只需要提供一个“接待员”即可</li><li>定义系统的入口</li></ul><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>减少系统相互依赖</li><li>提高灵活性</li><li>提高了安全性</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>不符合开闭原则，如果要改东西很麻烦，继承重写都不合适</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>绘制图形</p><pre><code>public interface Shape {    void draw();}</code></pre><pre><code>public class Rectangle implements Shape {    @Override    public void draw() {        System.out.println(&quot;Rectangle::draw&quot;);    }}</code></pre><pre><code>public class Square implements Shape {    @Override    public void draw() {        System.out.println(&quot;square::draw()&quot;);    }}</code></pre><pre><code>public class ShapeMaker {    private Shape rectangle;    private Shape square;    public ShapeMaker() {        rectangle = new Rectangle();        square = new Square();    }    public void drawRectangle() {        rectangle.draw();    }    public void drawSquare() {        square.draw();    }}</code></pre><pre><code>public class Test {    public static void main(String[] args) {        ShapeMaker maker = new ShapeMaker();        maker.drawRectangle();        maker.drawSquare();    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组合模式</title>
      <link href="/2018/10/18/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/10/18/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="组合模式（部分整体模式）"><a href="#组合模式（部分整体模式）" class="headerlink" title="组合模式（部分整体模式）"></a>组合模式（部分整体模式）</h2><p>用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。</p><a id="more"></a><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>高层模块调用简单</li><li>节点自由增加</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><pre><code>import java.util.ArrayList;import java.util.List;public class Employee {    private String name;    private String dept;    private int salary;    private List&lt;Employee&gt; subordinates;    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public String getDept() {        return dept;    }    public void setDept(String dept) {        this.dept = dept;    }    public int getSalary() {        return salary;    }    public void setSalary(int salary) {        this.salary = salary;    }    public List&lt;Employee&gt; getSubordinates() {        return subordinates;    }    public void setSubordinates(List&lt;Employee&gt; subordinates) {        this.subordinates = subordinates;    }    public Employee(String name, String dept, int salary, List&lt;Employee&gt; subordinates) {        super();        this.name = name;        this.dept = dept;        this.salary = salary;        this.subordinates = subordinates;        subordinates = new ArrayList&lt;Employee&gt;();    }    public Employee(String name, String dept, int salary) {        super();        this.name = name;        this.dept = dept;        this.salary = salary;        subordinates = new ArrayList&lt;Employee&gt;();    }    @Override    public String toString() {        return &quot;Employee [name=&quot; + name + &quot;, dept=&quot; + dept + &quot;, salary=&quot; + salary + &quot;, subordinates=&quot; + subordinates                + &quot;]&quot;;    }    public void add(Employee e) {        subordinates.add(e);    }    public void remove(Employee e) {        subordinates.remove(e);    }}</code></pre><pre><code>public class CompositePatternDemo {    public static void main(String[] args) {        Employee CEO = new Employee(&quot;John&quot;, &quot;CEO&quot;, 30000);        Employee headSales = new Employee(&quot;Robert&quot;, &quot;Head Sales&quot;, 20000);        Employee headMarketing = new Employee(&quot;Michel&quot;, &quot;Head Marketing&quot;, 20000);        Employee clerk1 = new Employee(&quot;Laura&quot;, &quot;Marketing&quot;, 10000);        Employee clerk2 = new Employee(&quot;Bob&quot;, &quot;Marketing&quot;, 10000);        Employee salesExecutive1 = new Employee(&quot;Richard&quot;, &quot;Sales&quot;, 10000);        Employee salesExecutive2 = new Employee(&quot;Rob&quot;, &quot;Sales&quot;, 10000);        CEO.add(headSales);        CEO.add(headMarketing);        headSales.add(salesExecutive1);        headSales.add(salesExecutive2);        headMarketing.add(clerk1);        headMarketing.add(clerk2);        // 打印该组织的所有员工        System.out.println(&quot;-------------------公司员工情况----------------------&quot;);        System.out.println(CEO);        for (Employee headEmployee : CEO.getSubordinates()) {            // 打印CEO的直属一级部下            System.out.println(headEmployee);            for (Employee employee : headEmployee.getSubordinates()) {                // 打印CEO的二级部下                System.out.println(employee);            }        }    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>过滤器模式</title>
      <link href="/2018/10/17/%E8%BF%87%E6%BB%A4%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/10/17/%E8%BF%87%E6%BB%A4%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="过滤器模式（标准模式）"><a href="#过滤器模式（标准模式）" class="headerlink" title="过滤器模式（标准模式）"></a>过滤器模式（标准模式）</h2><p>允许开发人员使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式把他们连接起来</p><a id="more"></a><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>Person类有三个属性：姓名（Name）、性别（Gender）和婚姻情况（Marital），我们的系统中的一些功能需要对这些属性进行筛选，比如：<br>1) 得到所有的男性；<br>2) 得到所有的女性；<br>3) 得到所有还单身的人；<br>4) 得到所有已婚的人。  </p><p>系统还希望能够将这些条件组合起来进行筛选，比如：<br>1)  得到所有已婚男性；<br>2)  得到所有单身女性；<br>3)  得到所有已婚的人或女性；</p><pre><code>public class Person {    private String name; // 姓名    private String gender; // 年龄    private String marital; // 婚姻状况    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public String getGender() {        return gender;    }    public void setGender(String gender) {        this.gender = gender;    }    public String getMarital() {        return marital;    }    public void setMarital(String marital) {        this.marital = marital;    }    public Person(String name, String gender, String marital) {        super();        this.name = name;        this.gender = gender;        this.marital = marital;    }    @Override    public String toString() {        return &quot;Person [name=&quot; + name + &quot;, gender=&quot; + gender + &quot;, marital=&quot; + marital + &quot;] \r&quot;;    }}</code></pre><pre><code>import java.util.List;public interface Filter {    /**     * 对传过来的person列表，根据一定条件进行过滤     * @param persons     * @return     */    List&lt;Person&gt; filter(List&lt;Person&gt; persons);}</code></pre><pre><code>import java.util.ArrayList;import java.util.List;public class MaleFilter implements Filter {    @Override    public List&lt;Person&gt; filter(List&lt;Person&gt; persons) {        List&lt;Person&gt; result = new ArrayList&lt;&gt;();        for (Person person : persons) {            if (&quot;MALE&quot;.equalsIgnoreCase(person.getGender())) {                  result.add(person);               }        }        return result;    }}</code></pre><pre><code>import java.util.ArrayList;import java.util.List;public class SingleFilter implements Filter {    @Override    public List&lt;Person&gt; filter(List&lt;Person&gt; persons) {        List&lt;Person&gt; result = new ArrayList&lt;&gt;();        for (Person person : persons) {            if (&quot;SINGLE&quot;.equalsIgnoreCase(person.getMarital())) {                  result.add(person);               }        }        return result;    }}</code></pre><pre><code>import java.util.List;public class FilterAnd implements Filter {    private Filter filter;    private Filter otherFilter;    public FilterAnd(Filter filter, Filter otherFilter) {        super();        this.filter = filter;        this.otherFilter = otherFilter;    }    @Override    public List&lt;Person&gt; filter(List&lt;Person&gt; persons) {        List&lt;Person&gt; tempList = filter.filter(persons);        return otherFilter.filter(tempList);    }}</code></pre><pre><code>import java.util.List;public class FilterOr implements Filter {    private Filter filter;    private Filter otherFilter;    public FilterOr(Filter filter, Filter otherFilter) {        this.filter = filter;        this.otherFilter = otherFilter;    }    @Override    public List&lt;Person&gt; filter(List&lt;Person&gt; persons) {         List&lt;Person&gt; tmpList1 = filter.filter(persons);            List&lt;Person&gt; tmpList2 = otherFilter.filter(persons);            for (Person person : tmpList2) {               if (!tmpList1.contains(person)) {                  tmpList1.add(person);               }            }            return tmpList1;      }}</code></pre><pre><code>import java.util.ArrayList;import java.util.List;public class Test {    public static void main(String[] args) {        // 初始化数据        List&lt;Person&gt; persons = new ArrayList&lt;&gt;();        persons.add(new Person(&quot;霍一&quot;, &quot;FEMALE&quot;, &quot;MARRIED&quot;));        persons.add(new Person(&quot;邓二&quot;, &quot;MALE&quot;, &quot;MARRIED&quot;));        persons.add(new Person(&quot;张三&quot;, &quot;MALE&quot;, &quot;SINGLE&quot;));        persons.add(new Person(&quot;李四&quot;, &quot;FEMALE&quot;, &quot;MARRIED&quot;));        persons.add(new Person(&quot;王五&quot;, &quot;MALE&quot;, &quot;SINGLE&quot;));        persons.add(new Person(&quot;赵六&quot;, &quot;FEMALE&quot;, &quot;SINGLE&quot;));        persons.add(new Person(&quot;孙七&quot;, &quot;MALE&quot;, &quot;SINGLE&quot;));        persons.add(new Person(&quot;罗八&quot;, &quot;MALE&quot;, &quot;MARRIED&quot;));        persons.add(new Person(&quot;刘九&quot;, &quot;FEMALE&quot;, &quot;SINGLE&quot;));        persons.add(new Person(&quot;史十&quot;, &quot;FEMALE&quot;, &quot;SINGLE&quot;));        // 所有男性        System.out.println(&quot;男性===========================&quot;);        System.out.println(new MaleFilter().filter(persons));        System.out.println(&quot;单身===========================&quot;);        System.out.println(new SingleFilter().filter(persons));        System.out.println(&quot;单身男性===========================&quot;);        System.out.println(new FilterAnd(new MaleFilter(), new SingleFilter()).filter(persons));        System.out.println(&quot;单身或男性===========================&quot;);        System.out.println(new FilterOr(new MaleFilter(), new SingleFilter()).filter(persons));    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>桥接模式</title>
      <link href="/2018/10/16/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/10/16/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><p>将抽象部分和实现部分分离，使他们可以独立的变化。它是一种对象结构型模式，又称为柄体(Handle and Body)模式或接口(Interfce)模式。<br>桥接模式将继承关系转化成关联关系，它降低了类与类之间的耦合度，减少了系统中类的数量，也减少了代码量。</p><a id="more"></a><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>抽象和实现的分离</li><li>优秀的扩展能力</li><li>实现细节对客户的透明</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>创建一个连接数据库的驱动,然后对每一个数据库提供各自的实现.对于使用某一个数据库的时候只需要切换一下就行.</p><pre><code>public interface Driver {    public void connect();}</code></pre><pre><code>public class MysqlDriver implements Driver {    @Override    public void connect() {        System.out.println(&quot;连接mysql数据库&quot;);    }}</code></pre><pre><code>public class SqlServer implements Driver {    @Override    public void connect() {        System.out.println(&quot;连接sqlserver&quot;);    }}</code></pre><pre><code>public abstract class Bridge {    private Driver driver;    public Driver getDriver() {        return driver;    }    public void setDriver(Driver driver) {        this.driver = driver;    }    public void connect() {        driver.connect();    }}</code></pre><pre><code>public class MyBridge extends Bridge {}</code></pre><pre><code>public class Test {    public static void main(String[] args) {        Bridge bridge = new MyBridge();        Driver driver = new MysqlDriver();        bridge.setDriver(driver);        bridge.connect();    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型模式</title>
      <link href="/2018/10/16/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/10/16/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="模型模式"><a href="#模型模式" class="headerlink" title="模型模式"></a>模型模式</h2><p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p><a id="more"></a><h2 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h2><ul><li>实现克隆操作，在JAVA继承Cloneable，重写clone();  </li><li>用于隔离类对象的使用者和具体类型之间的耦合关系</li></ul><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>提高性能</li><li>逃避构造函数的约束</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。</li><li>必须实现 Cloneable 接口。</li></ul><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><pre><code>public abstract class Shape implements Cloneable {    private String id;    protected String type;    abstract void draw();    public String getId() {        return id;    }    public void setId(String id) {        this.id = id;    }    public String getType() {        return type;    }    public void setType(String type) {        this.type = type;    }    @Override    protected Object clone() {        Object clone = null;        try {            clone = super.clone();        } catch (CloneNotSupportedException e) {            e.printStackTrace();        }        return clone;    }}</code></pre><pre><code>public class Circle extends Shape {    public Circle() {        type = &quot;Circle&quot;;    }    @Override    void draw() {        System.out.println(&quot;circle&quot;);    }}</code></pre><pre><code>public class Square extends Shape {    public Square() {        type = &quot;square&quot;;    }    @Override    void draw() {        System.out.println(&quot;square&quot;);    }}</code></pre><pre><code>import java.util.Hashtable;public class ShapeCache {    private static Hashtable&lt;String, Shape&gt; shapeMap = new Hashtable&lt;&gt;();    public static Shape getShape(String shapeId) {        Shape cashShape = shapeMap.get(shapeId);        return (Shape) cashShape.clone();    }    public static void loadCache() {          Circle circle = new Circle();          circle.setId(&quot;1&quot;);          shapeMap.put(circle.getId(),circle);          Square square = new Square();          square.setId(&quot;2&quot;);          shapeMap.put(square.getId(),square);       }}</code></pre><pre><code>public class Test {    public static void main(String[] args) {        ShapeCache.loadCache();        Shape s1 = ShapeCache.getShape(&quot;1&quot;);        System.out.println(s1.getType());        Shape s2 = ShapeCache.getShape(&quot;2&quot;);        System.out.println(s2.getType());    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>建造者模式</title>
      <link href="/2018/10/15/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/10/15/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。简单点讲，就是使用多个简单的对象一步一步构建成一个复杂的对象，属于创建型模式，提供了一种创建对象的最佳方式。</p><a id="more"></a><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>建造者独立，容易扩展</li><li>便于控制细节风险</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>产品必须有共同点，范围有限制</li><li>内部变化复杂，会有很多的建造类</li></ul><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>以lol 盖伦、赵信召唤师为例,召唤师都有名称和qwer技能</p><pre><code>package pattern;public class Hero {    private String name;    private String qskill;    private String wskill;    private String eskill;    private String rskill;    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public String getQskill() {        return qskill;    }    public void setQskill(String qskill) {        this.qskill = qskill;    }    public String getWskill() {        return wskill;    }    public void setWskill(String wskill) {        this.wskill = wskill;    }    public String getEskill() {        return eskill;    }    public void setEskill(String eskill) {        this.eskill = eskill;    }    public String getRskill() {        return rskill;    }    public void setRskill(String rskill) {        this.rskill = rskill;    }    @Override    public String toString() {        return &quot;Hero [name=&quot; + name + &quot;, qskill=&quot; + qskill + &quot;, wskill=&quot; + wskill + &quot;, eskill=&quot; + eskill + &quot;, rskill=&quot;                + rskill + &quot;]&quot;;    }}</code></pre><pre><code>package pattern;public interface HeroBuilder {    void createName();    void createqSkill();    void createwSkill();    void createeSkill();    void createrSkill();    Hero createHero();}</code></pre><pre><code>package pattern;public class Gailun implements HeroBuilder {    private Hero hero;    @Override    public void createName() {        hero.setName(&quot;盖伦&quot;);    }    @Override    public void createqSkill() {        hero.setQskill(&quot;q:致命打击&quot;);    }    @Override    public void createwSkill() {        hero.setWskill(&quot;w:勇气&quot;);    }    @Override    public void createeSkill() {        hero.setEskill(&quot;e:审判&quot;);    }    @Override    public void createrSkill() {        hero.setRskill(&quot;r:德玛西亚正义&quot;);    }    @Override    public Hero createHero() {        return hero;    }    public Gailun() {        hero = new Hero();    }}</code></pre><pre><code>package pattern;public class Zhaoxin implements HeroBuilder {    private Hero hero;    @Override    public void createName() {        hero.setName(&quot;赵信&quot;);    }    @Override    public void createqSkill() {        hero.setQskill(&quot;q:三重爪击&quot;);    }    @Override    public void createwSkill() {        hero.setWskill(&quot;w:风斩电刺&quot;);    }    @Override    public void createeSkill() {        hero.setEskill(&quot;e:无畏冲锋&quot;);    }    @Override    public void createrSkill() {        hero.setRskill(&quot;r:新月护卫&quot;);    }    @Override    public Hero createHero() {        return hero;    }    public Zhaoxin() {        hero = new Hero();    }}</code></pre><pre><code>package pattern;public class Director {    public Hero createHero(HeroBuilder hero){        hero.createName();        hero.createeSkill();        hero.createqSkill();        hero.createwSkill();        hero.createrSkill();        return hero.createHero();    }}</code></pre><pre><code>package pattern;public class Test {    public static void main(String[] args) {        Director d= new Director();        // 创建赵信        Hero zhaoxin = d.createHero(new Zhaoxin());        System.out.println(zhaoxin.toString());        // 创建盖伦        Hero gailun = d.createHero(new Gailun());        System.out.println(gailun.toString());    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抽象工厂模式</title>
      <link href="/2018/10/12/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/10/12/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><a id="more"></a><p>在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>画红黄蓝三种颜色的圆、长方形</p><pre><code>package factory;public abstract class AbstractFactory {    public abstract Color getColor(String color);    public abstract Shape getShape(String shape);}</code></pre><pre><code>package factory;public class ColorFactory extends AbstractFactory {    @Override    public Color getColor(String color) {        if (color == null) {            return null;        }        if (color.equalsIgnoreCase(&quot;RED&quot;)) {            return new Red();        } else if (color.equalsIgnoreCase(&quot;YELLOW&quot;)) {            return new Yellow();        } else if (color.equalsIgnoreCase(&quot;BLUE&quot;)) {            return new Blue();        }        return null;    }    @Override    public Shape getShape(String shape) {        return null;    }}</code></pre><pre><code>package factory;public class ShapeFactory extends AbstractFactory{    @Override    public Color getColor(String color) {        return null;    }    @Override    public Shape getShape(String shape) {        if (shape == null) {            return null;        }        if (shape.equalsIgnoreCase(&quot;CIRCLE&quot;)) {            return new Circle();        } else if (shape.equalsIgnoreCase(&quot;RECTANGLE&quot;)) {            return new Rectangle();        }        return null;    }}</code></pre><pre><code>package factory;public interface Color {    void fill();}</code></pre><pre><code>package factory;public class Blue implements Color {    @Override    public void fill() {        System.out.println(&quot;蓝色&quot;);    }}</code></pre><pre><code>package factory;public class Red implements Color {    @Override    public void fill() {        System.out.println(&quot;红色&quot;);    }}</code></pre><pre><code>package factory;public class Yellow implements Color {    @Override    public void fill() {        System.out.println(&quot;黄色&quot;);    }}</code></pre><pre><code>package factory;public interface Shape {    void draw();}</code></pre><pre><code>package factory;public class Circle implements Shape {    @Override    public void draw() {        System.out.println(&quot;圆形&quot;);    }}</code></pre><pre><code>package factory;public class Rectangle implements Shape {    @Override    public void draw() {        System.out.println(&quot;长方形&quot;);    }}</code></pre><pre><code>package factory;public class Test {    public static void main(String[] args) {        AbstractFactory shapeFactory = FactoryProducer.getFactory(&quot;SHAPE&quot;);        Shape shape = shapeFactory.getShape(&quot;CIRCLE&quot;);        shape.draw();        AbstractFactory colorFactory = FactoryProducer.getFactory(&quot;COLOR&quot;);        Color color = colorFactory.getColor(&quot;RED&quot;);        color.fill();    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单工厂模式</title>
      <link href="/2018/10/12/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/10/12/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>工厂方法模式（英语：Factorymethod pattern）是一种实现了“工厂”概念的面向对象设计模式。就像其他创建型模式一样，它也是处理在不指定对象具体类型的情况下创建对象的问题。工厂方法模式的实质是“定义一个创建对象的接口，但让</p><a id="more"></a><p>实现这个接口的类来决定实例化哪个类。工厂方法让类的实例化推迟到子类中进行。”</p><p>创建一个对象常常需要复杂的过程，所以不适合包含在一个复合对象中。创建对象可能会导致大量的重复代码，可能会需要复合对象访问不到的信息，也可能提供不了足够级别的抽象，还可能并不是复合对象概念的一部分。工厂方法模式通过定义一个单独的创建对象的方法来解决这些问题。由子类实现这个方法来创建具体类型的对象。  </p><p>对象创建中的有些过程包括决定创建哪个对象、管理对象的生命周期，以及管理特定对象的创建和销毁的概念。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>一个调用者想创建一个对象，只要知道其名称就可以了</li><li>扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以</li><li>屏蔽产品的具体实现，调用者只关心产品的接口</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。</p><h4 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h4><ol><li>理财项目中，现金券、加息券、体验金的生成</li><li>Hibernate 换数据库</li></ol><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。</p><pre><code>package factory;public interface Card {    public void CardE();}</code></pre><pre><code>package factory;public class CashCard implements Card {    @Override    public void CardE() {        System.out.println(&quot;现金券&quot;);    }}</code></pre><pre><code>package factory;public class ExperienceCard implements Card {    @Override    public void CardE() {        System.out.println(&quot;体验金&quot;);    }}</code></pre><pre><code>package factory;public class InterestCard implements Card {    @Override    public void CardE() {        System.out.println(&quot;加息券&quot;);    }}</code></pre><pre><code>package factory;public class CardFactory {    public Card createCard(String type) {        if (&quot;&quot;.equals(type)) {            return null;        } else if (&quot;CASH&quot;.equals(type)) {            return new CashCard();        } else if (&quot;EXPERIENCE&quot;.equals(type)) {            return new ExperienceCard();        } else if (&quot;INTEREST&quot;.equals(type)) {            return new InterestCard();        }        return null;    }}</code></pre><pre><code>package factory;public class Test {    public static void main(String[] args) {        CardFactory factory = new CardFactory();        // 生成现金券        Card cash = factory.createCard(&quot;CASH&quot;);        cash.CardE();        // 生成体验金        Card experience = factory.createCard(&quot;EXPERIENCE&quot;);        experience.CardE();    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/2018/10/12/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/10/12/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>单例模式，属于创建型模式，提供了一种对象创建的最佳方式。它确保了一个类只有一个实例，并提供了一个全局访问点。  </p><a id="more"></a><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ul><li><p>单例类只能有一个实例</p></li><li><p>单例类必须自己创建自己的唯一实例</p></li><li><p>单例类必须给所有其他对象提供这一实例  </p><h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>保证一个类仅有一个实例，并提供一个访问他的全局访问点</p><h3 id="主要解决"><a href="#主要解决" class="headerlink" title="主要解决"></a>主要解决</h3><p>一个全局使用的类频繁的创建和销毁</p><h3 id="何时使用"><a href="#何时使用" class="headerlink" title="何时使用"></a>何时使用</h3><p>当你想控制实例数目，节省系统资源的时候</p><h3 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h3><p>判断系统是否有这个实例，有则返回，无则创建</p><h3 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h3><p>私有构造函数</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>减少了内存开销，避免了实例的频繁创建和销毁</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>无接口，不能继承，与单一职责冲突</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。</p><h3 id="单例模式的几种实现方式"><a href="#单例模式的几种实现方式" class="headerlink" title="单例模式的几种实现方式"></a>单例模式的几种实现方式</h3><h6 id="1-懒汉式，线程不安全"><a href="#1-懒汉式，线程不安全" class="headerlink" title="1. 懒汉式，线程不安全"></a>1. 懒汉式，线程不安全</h6><pre><code>public class Singleton {    private static Singleton instance;    private Singleton (){}    public static Singleton getInstance() {        if (instance == null) {            instance = new Singleton();        }        return instance;    }  }</code></pre><h6 id="2-懒汉式，线程安全"><a href="#2-懒汉式，线程安全" class="headerlink" title="2.懒汉式，线程安全"></a>2.懒汉式，线程安全</h6><pre><code>public class Singleton {    private static Singleton instance;    private Singleton (){}    public static synchronized Singleton getInstance() {        if (instance == null) {            instance = new Singleton();        }        return instance;    }  }</code></pre><p>这种加了synchronized，具有很好的懒加载（需要用到创建实例的时候再去创建实例），能够在多线程中很好的工作，但正是由于加了同步，虽然保证了单例，却影响了效率</p><h6 id="3-饿汉式，线程安全"><a href="#3-饿汉式，线程安全" class="headerlink" title="3. 饿汉式，线程安全"></a>3. 饿汉式，线程安全</h6><pre><code>public class Singleton {    private static Singleton instance = new Singleton();    private Singleton (){}  public static Singleton getInstance() {        return instance;    }  }</code></pre><p>static确保了，类在加载的时候，就已经实例了，所以确保了线程安全。缺点是资源效率不高，可能getInstance()永远不会执行到，但执行该类的其他静态方法或者加载了该类（class.forName)，那么这个实例仍然初始化，这个时候，就浪费了内存，产生了垃圾对象，达不到lazy loading的效果了</p><h6 id="4-双检锁-双重校验锁（DCL，即-double-checked-locking-）"><a href="#4-双检锁-双重校验锁（DCL，即-double-checked-locking-）" class="headerlink" title="4.双检锁/双重校验锁（DCL，即 double-checked locking ）"></a>4.双检锁/双重校验锁（DCL，即 double-checked locking ）</h6><pre><code>public class Singleton {    private volatile static Singleton singleton;    private Singleton (){}    public static Singleton getInstance() {        if (singleton == null) {            synchronized (Singleton.class) {                if (singleton == null) {                    singleton = new Singleton();                }            }        }        return singleton;    }  }</code></pre><p>这种方式采用双锁机制，安全且在多线程情况下能保持高性能。</p><h6 id="5-登记式-静态内部类"><a href="#5-登记式-静态内部类" class="headerlink" title="5.登记式/静态内部类"></a>5.登记式/静态内部类</h6><pre><code>public class Singleton {    private static class SingletonHolder {        private static final Singleton INSTANCE = new Singleton();    }    private Singleton (){}    public static final Singleton getInstance() {        return SingletonHolder.INSTANCE;    }  }</code></pre><h6 id="6-枚举"><a href="#6-枚举" class="headerlink" title="6.枚举"></a>6.枚举</h6><pre><code>public enum SingletonEnum {    /**   * 1.从Java1.5开始支持;   * 2.无偿提供序列化机制;   * 3.绝对防止多次实例化，即使在面对复杂的序列化或者反射攻击的时候;   */    instance;    private String others;    SingletonEnum() {}}</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>策略模式</title>
      <link href="/2018/10/12/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/10/12/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><blockquote><p>定义了算法族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户，属于行为型模式。  </p></blockquote><h6 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h6><p>定义一系列的算法，把他们一个个封装起来，使他们可以相互替换  </p><h6 id="主要解决"><a href="#主要解决" class="headerlink" title="主要解决"></a>主要解决</h6><p>在有多种算法相似的情况下，使用if…else所带来的复杂和难以维护  </p><h6 id="何时使用"><a href="#何时使用" class="headerlink" title="何时使用"></a>何时使用</h6><p>一个系统有许多许多类，而区分他们的只是他们的直接行为  </p><h6 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h6><p>实现一个接口  </p><h6 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h6><ol><li><p>计算器的算法  </p></li><li><p>实现一个项目的多个主题</p></li><li><p>shiro</p></li></ol><h6 id="计算器demo"><a href="#计算器demo" class="headerlink" title="计算器demo"></a>计算器demo</h6><ol><li><p>定义接口</p><pre><code>package caculator.service;</code></pre></li></ol><p>   public interface Operation {</p><p>   public int doOperation(int args1, int args2);</p><p>   }</p><pre><code>2. 实现</code></pre><p>   package caculator.service.Impl;</p><p>   import caculator.service.Operation;</p><p>   public class OperationAdd implements Operation {</p><p>   @Override</p><p>   public int doOperation(int args1, int args2) {</p><p>   return args1 + args2;</p><p>   }</p><p>   }</p><pre><code></code></pre><p>   package caculator.service.Impl;</p><p>   import caculator.service.Operation;</p><p>   public class OperationSubstract implements Operation {</p><p>   @Override</p><p>   public int doOperation(int args1, int args2) {</p><p>   return args1 - args2;</p><p>   }</p><p>   }</p><pre><code>3. 调用</code></pre><p>   package caculator.biz;</p><p>   import caculator.service.Operation;</p><p>   public class Caculator {</p><p>   private Operation operation;</p><p>   public void setOperation(Operation operation) {</p><p>   this.operation = operation;</p><p>   }</p><p>   public int doOperation(int args1, int args2) {</p><p>   return operation.doOperation(args1, args2);</p><p>   }</p><p>   public Caculator() {</p><p>   super();</p><p>   }</p><p>   }</p><pre><code>4. 测试</code></pre><p>   package caculator.test;</p><p>   import caculator.biz.Caculator;</p><p>   import caculator.service.Impl.OperationAdd;</p><p>   public class CaculatorTest {</p><p>   public static void main(String[] args) {</p><p>   Caculator caculator = new Caculator();</p><p>   caculator.setOperation(new OperationAdd());</p><p>   System.out.println(caculator.doOperation(15, 3));;</p><p>   }</p><p>   }<br>   ```</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>遵循开闭原则，扩展性好  </p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li><p>随着策略增加，类越来越多</p></li><li><p>所有的策略类都要暴露出去</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>装饰器模式</title>
      <link href="/2018/10/12/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/10/12/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><p>允许向一个现有的对象添加新的功能，但又不改变其结构，属于结构型模式。</p><h5 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h5><p>动态的给一个对象添加一些额外的指责。就增加功能来说，装饰器模式相比生成子类更为灵活  </p><p><strong>##### 主要解决</strong></p><p>一般的，我们为扩展子类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀</p><h5 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h5><p>将具体功能指责划分，同时继承装饰者模式</p><h5 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h5><ol><li><p>Component类充当抽象角色，不应该具体实现  </p></li><li><p>修饰类引用和继承Component类，具体扩展类重写父类方法     </p></li></ol><h5 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h5><p>动态组合，动态是手段，组合是目的</p><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p>装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能  </p><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p>多层装饰比较复杂</p><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><ol><li><p>扩展一个类的功能</p></li><li><p>动态增加功能，动态撤销</p></li></ol><h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><p>可替代继承</p><h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h5><h6 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h6><p>一个游戏有三个角色，每个角色对应多个技能</p><h6 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h6><ol><li><p>抽象构建</p><pre><code>package game;</code></pre></li></ol><p>   public interface Hero {</p><p>   void deatil();</p><p>   }</p><pre><code>2. 具体构建</code></pre><p>   package game;<br>   public class ManHero implements Hero {<br>   @Override<br>   public void deatil() {<br>       System.out.println(“男性角色”);<br>       }<br>   }</p><pre><code></code></pre><p>   package game;</p><p>   public class WomanHero implements Hero {<br>   @Override<br>   public void deatil() {<br>       System.out.println(“女性角色”);<br>       }<br>   }</p><pre><code>3. 装饰角色</code></pre><p>   package game;</p><p>   /**</p><p>   * 抽象装饰类</p><p>   * @author missj</p><p>   *</p><p>   */</p><p>   public abstract class HeroDetail implements Hero {</p><p>   protected Hero hero;</p><p>   public HeroDetail(Hero hero) {</p><p>   super();</p><p>   this.hero = hero;</p><p>   }</p><p>   public void deatil() {</p><p>   hero.deatil();</p><p>   }</p><p>   }</p><pre><code>4. 具体装饰角色</code></pre><p>   package game;</p><p>   public class NpcHero extends HeroDetail {</p><p>   public NpcHero(Hero hero) {</p><p>   super(hero);</p><p>   }</p><p>   @Override</p><p>   public void deatil() {</p><p>   hero.deatil();</p><p>   describe(hero);</p><p>   }</p><p>   private void describe(Hero hero) {</p><p>   System.out.println(“this is npc”);</p><p>   }</p><p>   }</p><pre><code>5. 测试</code></pre><p>   package game;</p><p>   public class Test {<br>   public static void main(String[] args) {<br>       Hero hero = new ManHero();<br>       Hero npcHero = new NpcHero(hero);<br>       npcHero.deatil();<br>       }<br>   }</p><pre><code></code></pre>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>观察者模式</title>
      <link href="/2018/10/11/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/10/11/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="观察者模式-发布-订阅模式"><a href="#观察者模式-发布-订阅模式" class="headerlink" title="观察者模式(发布-订阅模式)"></a>观察者模式(发布-订阅模式)</h1><blockquote><p>观察者模式定义了一对多的依赖，当一个对象状态发生变化时，他的所有依赖者都会收到通知并自动更新。属于行为型模式。   </p></blockquote><a id="more"></a><h3 id="主要解决"><a href="#主要解决" class="headerlink" title="主要解决"></a>主要解决</h3><p>一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作  </p><h3 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h3><p>在抽象类里又一个ArrayList存放观察者们  </p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>观察者和被观察者是抽象耦合的</li><li>建立一套触发机制    </li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>如果一个被观察者对象有很多直接或间接的观察者，将所有观察者都通知到，会花费很多的时间</li><li>如果在观察者和观察目标之间有循环依赖的时候，观察目标会触发他们之间进行循环调用，导致系统的崩溃</li><li>观察模式没有相应的机制让观察者知道所观察的目标对象是怎样发生变化的，而仅仅是知道观察目标发生了变化。  </li></ol><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol><li>一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使他们可以各自独立的改变和复用</li><li>一个对象的改变将导致其他一个或多个对象的改变，而不知道具体有多少对象发生改变，可以降低对象之间的耦合度</li><li>一个对象必须通知其他对象，而并不知道这些对象是谁</li><li>需要在一个系统中创建触发链，A对象行为将影响B对象，B影响C…</li></ol><h3 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h3><p>微信公众号服务，关注者可收到推送消息，取消关注无法收到</p><pre><code>package demo;/*** 抽象被观察者接口* @author missj**/public interface Observerable {public void registerObserver(Observer o);public void removeObserver(Observer o);public void notifyObserver();}</code></pre><pre><code>package demo;import java.util.ArrayList;import java.util.List;/*** 定义被观察者* 微信公众号服务* @author missj**/public class WechatServer implements Observerable {// 观察者，面向接口编程private List&lt;Observer&gt; list;private String message;public WechatServer() {list = new ArrayList&lt;&gt;();}@Overridepublic void registerObserver(Observer o) {list.add(o);}@Overridepublic void removeObserver(Observer o) {list.remove(o);}@Overridepublic void notifyObserver() {for (Observer observer : list) {observer.update(message);}}public String getMessage() {return message;}public void setMessage(String message) {this.message = message;notifyObserver();}}</code></pre><pre><code>package demo;/*** 抽象观察者 定义了一个update（）方法，当被观察者调用notifyObsever（）方法时，观察者的update（）方法会被调用* * @author missj**/public interface Observer {public void update(String message);}</code></pre><pre><code>package demo;public class User implements Observer {private String name;private String message;public User(String name) {super();this.name = name;}@Overridepublic void update(String message) {this.message = message;read();}public void read() {System.out.println(name + &quot;推送消息&quot; + message);}}</code></pre><pre><code>package demo;import java.util.Date;public class Test {public static void main(String[] args) {WechatServer server = new WechatServer();server.setMessage(&quot;测试&quot;);// 定义三个观察者Observer u1 = new User(&quot;u1&quot;);Observer u2 = new User(&quot;u2&quot;);Observer u3 = new User(&quot;u3&quot;);server.registerObserver(u1);server.registerObserver(u2);server.registerObserver(u3);System.out.println(new Date());server.notifyObserver();server.removeObserver(u3);server.setMessage(&quot;测试2&quot;);}}</code></pre><h3 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h3><p>使用java提供的Observer实现案例1</p><pre><code>package demo2;import java.util.Observable;/*** 模拟公众号* @author missj**/public class WechatServer extends Observable {private String message;public void sendMessage(String message) {this.setChanged();this.notifyObservers(message);}public String getMessage() {return message;}public void setMessage(String message) {this.message = message;sendMessage(message);}}</code></pre><pre><code>package demo2;import java.util.Observable;import java.util.Observer;public class User implements Observer {private String name;@Overridepublic void update(Observable o, Object arg) {System.out.println(this.name + &quot;收到推送消息:&quot; + arg);}public String getName() {return name;}public void setName(String name) {this.name = name;}public User(String name) {super();this.name = name;}}</code></pre><pre><code>package demo2;import java.util.Observer;public class Test {public static void main(String[] args) {WechatServer server = new WechatServer();Observer user1 = new User(&quot;u1&quot;);Observer user2 = new User(&quot;u2&quot;);Observer user3 = new User(&quot;u3&quot;);server.addObserver(user1);server.addObserver(user2);server.addObserver(user3);server.setMessage(&quot;测试&quot;);server.deleteObserver(user3);System.out.println(&quot;===========&quot;);server.setMessage(&quot;测试2&quot;);}}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>适配器模式</title>
      <link href="/2018/10/11/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/10/11/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><p>将一个类的接口，转化成客户期望的另一个接口。让原本接口不兼容的类可以合作无间，属于结构型模式。<br>从结构上分为类适配器、对象适配器和缺省适配器，类适配器，提供一个实现该接口的类，并且扩展已有的类，通过创建</p><a id="more"></a><p>子类来实现适配，对象适配器使用对象引用进行适配。缺省适配器由一个抽象类实现，并且在抽象类中实现所有的方法，具体的子类都要继承此抽象类</p><h3 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h3><p>继承和依赖</p><h3 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h3><p>继承或依赖已有的对象，实现想要的目标接口</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>可以让任何两个没有关联的类一起运行</li><li>提高了类的复用</li><li>增加了类的透明度</li><li>灵活性好</li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>过多使用适配器会让系统非常凌乱，不易整体进行把握<br>至多只能适配一个适配器类，而且目标类必须是抽象类</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>适配器不是在项目初期使用的，而是解决现有代码接口不兼容时出现的</p><h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><p>实现一个接口中的部分方法</p><h5 id="类适配器实现"><a href="#类适配器实现" class="headerlink" title="类适配器实现"></a>类适配器实现</h5><pre><code>package demo1;/*** 目标角色* @author missj**/public interface Target {public void write();public void read();}</code></pre><pre><code>package demo1;/*** 源角色* @author missj**/public class Old {public void write() {System.out.println(&quot;write&quot;);}}</code></pre><pre><code>/*** 适配器* @author missj**/package demo1;public class Adapter extends Old implements Target {@Overridepublic void read() {System.out.println(&quot;read&quot;);}}</code></pre><pre><code>/*** 测试* @author missj**/package demo1;public class Test {public static void main(String[] args) {Target t = new Adapter();t.read();t.write();}}</code></pre><h5 id="对象配器实现"><a href="#对象配器实现" class="headerlink" title="对象配器实现"></a>对象配器实现</h5><pre><code>package demo2;/*** 源角色* @author missj**/public class Old {public void write() {System.out.println(&quot;write&quot;);}}</code></pre><pre><code>package demo2;/*** 目标角色* @author missj**/public interface Target {public void write();public void read();}</code></pre><pre><code>package demo2;/*** 适配器* @author missj**/public class Adapter implements Target {private Old old;public Adapter(Old old) {this.old = old;}public void write() {this.old.write();}public void read() {System.out.println(&quot;read&quot;);}}</code></pre><pre><code>package demo2;/*** 测试* @author missj**/public class Test {public static void main(String[] args) {Old old = new Old();Target t = new Adapter(old);t.write();t.read();}}</code></pre><h5 id="缺省配器实现"><a href="#缺省配器实现" class="headerlink" title="缺省配器实现"></a>缺省配器实现</h5><pre><code>package demo3;/*** 目标角色* @author missj**/public interface Target {public void write();public void read();}</code></pre><pre><code>package demo3;/*** 源角色* @author missj**/public class Old extends Adapter {public void write() {System.out.println(&quot;write&quot;);}}</code></pre><pre><code>package demo3;/*** 适配器* @author missj**/public abstract class Adapter implements Target {@Overridepublic void write() {}@Overridepublic void read() {System.out.println(&quot;read&quot;);}}</code></pre><pre><code>package demo3;/*** 测试* @author missj**/public class Test {public static void main(String[] args) {Target t = new Old();t.write();t.read();}}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2018/10/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/10/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p><a href="http://#span-id11-什么是设计模式span" target="_blank" rel="noopener"></a>  </p><h2 id="1-什么是设计模式"><a href="#1-什么是设计模式" class="headerlink" title="1. 什么是设计模式"></a>1. 什么是设计模式</h2><blockquote><p>设计模式是对软件设计过程中普遍存在的问题，提出的解决方案。换句话说，设计模式就是一套被反复使用，大多人知晓，经过分类的，代码设计的经验的总结。他是为了可重用代码，让代码更容易被他人理解，保证代码的高可靠性和高位户型</p></blockquote><a id="more"></a><p><a href="http://#span-id22-设计模式原则span" target="_blank" rel="noopener"></a>  </p><h2 id="2-设计模式原则"><a href="#2-设计模式原则" class="headerlink" title="2. 设计模式原则"></a>2. 设计模式原则</h2><h4 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a><a href="http://#开闭原则" target="_blank" rel="noopener"></a>开闭原则</h4><blockquote><p>对扩展开放，对修改关闭。在程序需要扩展的时候，不修改原有的代码或者对原来的代码产生影响，达到一个热插拔的效果。简而言之，就是为了使程序的扩展性更好，更容易维护和升级。想要达到这样一个效果，我们需要用到接口和继承类。</p></blockquote><h4 id="里氏代换原则"><a href="#里氏代换原则" class="headerlink" title="里氏代换原则"></a><a href="http://#里氏代换原则" target="_blank" rel="noopener"></a>里氏代换原则</h4><blockquote><p>里氏代换原则是面向对象设计的基本原则之一。里氏代换原则说，任何基类出现的地方，子类一定可以出现。里氏代换原则是继承复用的基石，只有当子类可以替换掉基类，且软件单位的功能不受到影响时，基类才能被复用，而且子类可以在基类的基础之上添加行的行为或属性。里氏代换原则是对开闭原则的补充，实现开闭原则的关键步骤就是抽象化，而基类与子类之间的关系就是抽象化的具体实现，所以里氏代换原则就是对实现抽象化具体步骤的规范。</p></blockquote><h4 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a><a href="http://#迪米特法则" target="_blank" rel="noopener"></a>迪米特法则</h4><blockquote><p>一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立</p></blockquote><h4 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a><a href="http://#依赖倒转原则" target="_blank" rel="noopener"></a>依赖倒转原则</h4><blockquote><p>开闭原则的基础。针对接口编程，高层模块不应该依赖于底层模块，二者都依赖于抽象，不依赖于具体</p></blockquote><h4 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a><a href="http://#单一职责原则" target="_blank" rel="noopener"></a>单一职责原则</h4><blockquote><p>类的职责要单一</p></blockquote><h4 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a><a href="http://#接口隔离原则" target="_blank" rel="noopener"></a>接口隔离原则</h4><blockquote><p>使用多个隔离的接口比使用单个庞大的接口好，其目的在于降低耦合。强调低依赖、低耦合。</p></blockquote><h4 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a><a href="http://#合成复用原则" target="_blank" rel="noopener"></a>合成复用原则</h4><blockquote><p>合成复用原则就是在一个新的对象里通过关联关系（组合关系、聚合关系）来使用一些已有的对象，使之成为新对象的一部分；新对象通过委派调用已有对象的方法达到复用功能的目的。简而言之，尽量多使用 组合/聚合 的方式，尽量少使用甚至不使用继承关系。</p></blockquote><table><thead><tr><th><span style="width:30%;">分类</span></th><th><span style="width:30%;">关注点</span></th><th><span style="width:40%;">包含</span></th></tr></thead><tbody><tr><td>创建型模式</td><td>关注于对象的创建，同时隐藏创建逻辑</td><td>工厂模式<br>抽象工厂模式<br>单例模式<br>建造者模式<br>原型模式<br></td></tr><tr><td>结构型模式</td><td>关注类与对象之间的组合</td><td>适配器模式<br>装饰模式<br>享元模式<br>代理模式<br>外观模式<br>组合模式<br>桥接模式<br></td></tr><tr><td>行为型模式</td><td>关注类与对象之间的通信</td><td>命令模式<br>中介者模式<br>观察者模式<br>状态模式<br>策略模式<br>模版模式<br>迭代器模式<br>备忘录模式<br>解释器模式<br>职责链模式<br>访问者模式<br></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
