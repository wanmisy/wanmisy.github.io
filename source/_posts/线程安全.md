---
title: 线程安全
date: 2018-12-16 21:27:27
tags:  [并发,线程,java,编程]
categories: 
- 并发
- 线程
---
## 线程不安全
多个线程同时操作一个数据结构的时候产生了相互修改和串行的情况，没有保证数据的不一致性
<!-- more -->
```(java)

public class NotSecuret {
	public static void main(String[] args) {
		Count count = new Count();
		for (int i = 0; i < 5; i++) {
			User user = new User(count);
			user.start();
		}
		try {
			Thread.sleep(1000);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		System.out.println("最后的值：" + count.num);
	}

}


class Count{
	public int num = 0;
	
	public void add() {
		try {
			// 模仿用户干活
			Thread.sleep(51);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		num++;
		System.out.println(Thread.currentThread().getName() + "-" + num);
	}
}

class User extends Thread{
	private Count count;
	
	
	public User(Count count) {
		super();
		this.count = count;
	}

	@Override
	public void run() {
		super.run();
		count.add();
	}
}
```
结果  
```(result)
Thread-0-4
Thread-2-4
Thread-4-4
Thread-3-4
Thread-1-4
最后的值：4
```

## 线程安全
```(java)

public class Securet {
	public static void main(String[] args) {
		Count count = new Count();
		for (int i = 0; i < 5; i++) {
			User user = new User(count);
			user.start();
		}
		try {
			Thread.sleep(1000);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		System.out.println("最后的值：" + count.num);
	}

}


class Count{
	public int num = 0;
	
	public synchronized void  add() {
		try {
			// 模仿用户干活
			Thread.sleep(51);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		num++;
		System.out.println(Thread.currentThread().getName() + "-" + num);
	}
}

class User extends Thread{
	private Count count;
	
	
	public User(Count count) {
		super();
		this.count = count;
	}

	@Override
	public void run() {
		super.run();
		count.add();
	}
}
```
结果  
```(result)
Thread-0-1
Thread-4-2
Thread-2-3
Thread-1-4
Thread-3-5
最后的值：5
```
实现线程的大致三种方法：  
1. 多实例
2. 使用java.util.concurrent下面的类库
3. 使用锁机制synchoronized、lock方法

### 隐示锁，又称线程同步synchoronized
用来修饰一个方法或一个代码块，保证在同一个时刻最多只有一个线程执行这段代码


